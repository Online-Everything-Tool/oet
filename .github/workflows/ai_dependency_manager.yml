# .github/workflows/ai_dependency_manager.yml
name: AI Dependency Manager

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR'] # Name of your main PR validation workflow
    types:
      - completed

jobs:
  resolve_dependencies:
    name: Resolve Tool Dependencies
    if: >
      github.event.workflow_run.conclusion != 'failure' &&
      github.event.workflow_run.head_branch != 'main' &&
      github.event.workflow_run.head_branch != github.event.repository.default_branch
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read # To download artifacts
      pull-requests: write # To comment and label

    env:
      # These come from the triggering workflow run event
      PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
      PR_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      PR_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }} # This is github.event.workflow_run.head_branch
      VET_DEPENDENCY_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/vet-dependency 

    steps:
      - name: Log Triggering Event Info
        run: |
          echo "Triggered by workflow run: ${{ github.event.workflow_run.id }} for PR #${{ env.PR_NUMBER }}"
          echo "Commit SHA: ${{ env.PR_HEAD_SHA }}"
          echo "Branch from workflow_run event: ${{ env.PR_HEAD_BRANCH }}"
          echo "Repo default branch: ${{ github.event.repository.default_branch }}"
          echo "Conclusion of triggering workflow: ${{ github.event.workflow_run.conclusion }}"
          if [ "${{ env.PR_HEAD_BRANCH }}" == "${{ github.event.repository.default_branch }}" ]; then
            echo "::warning::This job is running but PR_HEAD_BRANCH ('${{ env.PR_HEAD_BRANCH }}') is the default branch. This might be unexpected (job-level 'if' should prevent this)."
          fi

      - name: Download Pending Dependencies Artifact
        id: download_pending_deps
        uses: actions/download-artifact@v4
        with:
          name: pending-dependencies-${{ env.PR_HEAD_SHA }} 
          path: ${{ runner.temp }}/pending-deps-data
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true 

      - name: Check Artifact and Read Data
        id: check_artifact
        # This step only runs if download_pending_deps did not fatally error (due to continue-on-error)
        # and we then check its outcome.
        if: steps.download_pending_deps.outcome == 'success'
        run: |
          PENDING_DEPS_FILE="${{ runner.temp }}/pending-deps-data/pending_dependencies.json"
          if [ -f "$PENDING_DEPS_FILE" ] && [ -s "$PENDING_DEPS_FILE" ]; then
            echo "Pending dependencies artifact found and is not empty."
            cat "$PENDING_DEPS_FILE"
            echo "artifact_valid=true" >> $GITHUB_OUTPUT
            echo "pending_deps_path=$PENDING_DEPS_FILE" >> $GITHUB_OUTPUT
          else
            echo "::notice::Pending dependencies artifact ($PENDING_DEPS_FILE) downloaded but was empty/invalid. No dependencies to process for this run."
            echo "artifact_valid=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout PR Code
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PR_HEAD_SHA }}

      - name: Vet and Install Dependencies
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        id: vet_and_install
        run: |
          set -e 
          echo "--- Starting: Vet and Install Dependencies ---"
          PENDING_DEPS_FILE="${{ steps.check_artifact.outputs.pending_deps_path }}"
          
          echo "Contents of PENDING_DEPS_FILE ($PENDING_DEPS_FILE):"
          cat "$PENDING_DEPS_FILE" 

          TOOL_DIRECTIVE=$(jq -r '.toolDirective' "$PENDING_DEPS_FILE")
          TOOL_DESCRIPTION=$(jq -r '.toolDescription // "No tool description provided in artifact."' "$PENDING_DEPS_FILE") 
          ASSET_INSTRUCTIONS_FROM_ARTIFACT=$(jq -r '.assetInstructions // ""' "$PENDING_DEPS_FILE")
          
          NEW_DEPENDENCIES_JSON_ARRAY_STR=$(jq -r 'if .newDependencies and (.newDependencies | type == "array") then .newDependencies | tojson else "[]" end' "$PENDING_DEPS_FILE")

          VETTED_SAFE_PACKAGES_TMP_FILE=$(mktemp) 
          UNSAFE_DETAILS_TMP_FILE=$(mktemp)     
          MANUAL_REVIEW_TMP_FILE=$(mktemp)  

          ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="true" 

          if [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -eq 0 ]; then
            echo "No new dependencies listed in the artifact to vet or install."
            ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
          else
            echo "Processing ${NEW_DEPENDENCIES_JSON_ARRAY_STR} for vetting..."
            echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -c '.[]' | while IFS= read -r dep_json; do
              packageName=$(echo "$dep_json" | jq -r '.packageName')
              if [ "$packageName" == "null" ] || [ -z "$packageName" ]; then
                echo "::warning::Skipping dependency with no packageName."
                continue
              fi

              echo "--- Vetting dependency: $packageName for tool $TOOL_DIRECTIVE ---"
              echo "Tool Description for vetting: $TOOL_DESCRIPTION"
              echo "Asset Instructions for vetting (first 100 chars): ${ASSET_INSTRUCTIONS_FROM_ARTIFACT:0:100}..."

              API_PAYLOAD=$(jq -n \
                --arg pkg "$packageName" \
                --arg directive "$TOOL_DIRECTIVE" \
                --arg desc "$TOOL_DESCRIPTION" \
                --arg assetInst "$ASSET_INSTRUCTIONS_FROM_ARTIFACT" \
                '{packageName: $pkg, toolDirective: $directive, toolDescription: $desc, assetInstructions: $assetInst}')
              
              echo "Sending payload to VET_DEPENDENCY_API_ENDPOINT:"
              echo "$API_PAYLOAD"

              HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "${{ env.VET_DEPENDENCY_API_ENDPOINT }}" \
                -H "Content-Type: application/json" \
                -d "$API_PAYLOAD" \
                -o "${{ runner.temp }}/vet_response.json")
              
              echo "Vetting API response for $packageName (HTTP $HTTP_RESPONSE_CODE):"
              cat "${{ runner.temp }}/vet_response.json" 

              if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
                echo "::error::API call to vet $packageName failed (HTTP $HTTP_RESPONSE_CODE)."
                echo "'$packageName' (Vetting API call failed: HTTP $HTTP_RESPONSE_CODE)" >> "$UNSAFE_DETAILS_TMP_FILE"
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"
                continue 
              fi

              vetting_success=$(jq -r .success "${{ runner.temp }}/vet_response.json")
              if [ "$vetting_success" != "true" ] || ! jq -e .vettingResult "${{ runner.temp }}/vet_response.json" > /dev/null; then
                  api_message=$(jq -r .message "${{ runner.temp }}/vet_response.json")
                  echo "::error::Vetting API reported failure for $packageName: $api_message"
                  echo "'$packageName' (Vetting API error: $api_message)" >> "$UNSAFE_DETAILS_TMP_FILE"
                  ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"
                  continue
              fi

              isSafeAndRelevant=$(jq -r '.vettingResult.isLikelySafeAndRelevant' "${{ runner.temp }}/vet_response.json")
              makesExternalNetworkCalls=$(jq -r '.vettingResult.makesExternalNetworkCalls' "${{ runner.temp }}/vet_response.json")
              justification=$(jq -r '.vettingResult.justification' "${{ runner.temp }}/vet_response.json")

              echo "Debug: For $packageName -> isSafeAndRelevant='${isSafeAndRelevant}', makesExternalNetworkCalls='${makesExternalNetworkCalls}'"

              if [ "$isSafeAndRelevant" = "true" ] && [ "$makesExternalNetworkCalls" = "no" ]; then
                echo "$packageName" >> "$VETTED_SAFE_PACKAGES_TMP_FILE" 
                echo "$packageName deemed provisionally safe by vetting API."
              elif [ "$makesExternalNetworkCalls" = "yes" ]; then
                echo "'$packageName' (Reason: Makes external network calls. Justification: $justification)" >> "$UNSAFE_DETAILS_TMP_FILE"
                echo "::error::$packageName flagged by vetting as making external network calls."
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              else 
                echo "'$packageName' (Reason: Needs review. Vetting - Safe: $isSafeAndRelevant, Network: $makesExternalNetworkCalls. Justification: $justification)" >> "$MANUAL_REVIEW_TMP_FILE"
                echo "::warning::$packageName flagged for manual review by vetting API."
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              fi
            done 
          fi 

          mapfile -t provisionally_safe_packages < "$VETTED_SAFE_PACKAGES_TMP_FILE"
          mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE"
          mapfile -t manual_review_package_details < "$MANUAL_REVIEW_TMP_FILE"

          changes_made_to_package_json=false
          packages_actually_installed_this_run=()

          if [ "$ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT" = "true" ] && [ ${#provisionally_safe_packages[@]} -gt 0 ]; then
            echo "All identified new dependencies were vetted as safe. Checking against package.json for installation..."
            packages_to_npm_install=()
            for pkg_name in "${provisionally_safe_packages[@]}"; do
                if ! grep -q "\"$pkg_name\"" package.json; then
                    packages_to_npm_install+=("$pkg_name")
                else
                    echo "Dependency '$pkg_name' already found in package.json, skipping npm install for it."
                fi
            done
            
            if [ ${#packages_to_npm_install[@]} -gt 0 ]; then
                echo "Attempting to install: ${packages_to_npm_install[*]}"
                if npm install "${packages_to_npm_install[@]}" --save; then
                    echo "Successfully installed: ${packages_to_npm_install[*]}"
                    changes_made_to_package_json=true
                    packages_actually_installed_this_run=("${packages_to_npm_install[@]}")
                else
                    echo "::error::'npm install' command failed for some packages: ${packages_to_npm_install[*]}"
                    for pkg_failed in "${packages_to_npm_install[@]}"; do
                         echo "'$pkg_failed' (npm install command failed)" >> "$UNSAFE_DETAILS_TMP_FILE"
                    done
                    mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE" 
                    ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
                fi
            else
                echo "No new dependencies needed npm install (all vetted safe ones were already present in package.json)."
            fi
          elif [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -gt 0 ]; then
            echo "Not all dependencies were vetted as safe, or some failed vetting. No dependencies will be installed automatically by this run."
          else
            echo "No new dependencies were identified in the artifact. No installation action taken."
          fi
          
          rm "$VETTED_SAFE_PACKAGES_TMP_FILE" "$UNSAFE_DETAILS_TMP_FILE" "$MANUAL_REVIEW_TMP_FILE"

          echo "changes_made=$changes_made_to_package_json" >> $GITHUB_OUTPUT
          echo "unsafe_deps_count=${#unsafe_package_details[@]}" >> $GITHUB_OUTPUT
          
          UNSAFE_DETAILS_STR=$(IFS=$'\n'; echo "${unsafe_package_details[*]}")
          MANUAL_REVIEW_DETAILS_STR=$(IFS=$'\n'; echo "${manual_review_package_details[*]}")
          INSTALLED_DEPS_STR=$(IFS=' '; echo "${packages_actually_installed_this_run[*]}")

          echo "UNSAFE_DEPS_DETAILS<<EOF_UNSAFE" >> $GITHUB_ENV
          echo "$UNSAFE_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_UNSAFE" >> $GITHUB_ENV

          echo "MANUAL_REVIEW_DEPS_DETAILS<<EOF_MANUAL" >> $GITHUB_ENV
          echo "$MANUAL_REVIEW_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_MANUAL" >> $GITHUB_ENV
          
          echo "INSTALLED_DEPS_LIST=$INSTALLED_DEPS_STR" >> $GITHUB_ENV
          echo "--- Finished: Vet and Install Dependencies ---"

      - name: Prepare Outputs for Comment Script
        id: prepare_comment_data
        run: |
          echo "DOWNLOAD_PENDING_DEPS_OUTCOME=${{ steps.download_pending_deps.outcome }}" >> $GITHUB_ENV
          echo "CHECK_ARTIFACT_OUTPUTS_ARTIFACT_VALID=${{ steps.check_artifact.outputs.artifact_valid }}" >> $GITHUB_ENV
          echo "VET_AND_INSTALL_OUTPUTS_CHANGES_MADE=${{ steps.vet_and_install.outputs.changes_made }}" >> $GITHUB_ENV

      - name: Commit and Push Dependency Changes
        if: steps.vet_and_install.outputs.changes_made == 'true'
        env:
          GITHUB_TOKEN_FOR_PUSH: ${{ secrets.AI_LINT_FIXER_PAT }}
        run: |
          git config --global user.name "OET Dependency Bot"
          git config --global user.email "bot@online-everything-tool.com" 
          git add package.json package-lock.json
          COMMIT_MSG="chore: add auto-vetted dependencies"
          if [ -n "$INSTALLED_DEPS_LIST" ]; then 
            COMMIT_MSG="chore: add auto-vetted dependencies ($INSTALLED_DEPS_LIST)"
          fi
          git commit -m "$COMMIT_MSG"
          echo "Pushing dependency changes to branch ${{ env.PR_HEAD_BRANCH }}..."
          git push https://x-access-token:${GITHUB_TOKEN_FOR_PUSH}@github.com/${{ github.repository }}.git HEAD:${{ env.PR_HEAD_BRANCH }}

      - name: Trigger Re-validation via PR Comment After Dep Push
        if: steps.vet_and_install.outputs.changes_made == 'true' 
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.setFailed("ADM: Could not determine PR number for re-validation comment. This might happen if PR context was lost.");
              return;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: '/revalidate-ai-fixes' 
            });
            core.info(`ADM: Posted /revalidate-ai-fixes comment to PR #${prNumber} after dependency changes.`);

      - name: Post Summary Comment to PR
        uses: actions/github-script@v7
        if: always() 
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.warning("ADM: PR Number not available for summary comment. This is unexpected if the job ran. Skipping comment.");
              return; 
            }

            let commentBody = `## ðŸ¤– AI Dependency Manager Results for PR #${prNumber}\n\n`;
            // These are from vet_and_install's GITHUB_ENV or GITHUB_OUTPUT (unsafe_deps_count)
            const unsafeCount = parseInt(process.env.unsafe_deps_count || "0"); 
            const installedDeps = process.env.INSTALLED_DEPS_LIST || ""; 
            const unsafeDetails = process.env.UNSAFE_DEPS_DETAILS || ""; 
            const manualReviewDetails = process.env.MANUAL_REVIEW_DEPS_DETAILS || ""; 
            
            // These are from the 'Prepare Outputs for Comment Script' step via GITHUB_ENV
            const artifactDownloadSucceeded = process.env.DOWNLOAD_PENDING_DEPS_OUTCOME === 'success';
            const artifactWasValid = process.env.CHECK_ARTIFACT_OUTPUTS_ARTIFACT_VALID === 'true';
            const changesWereMadeByVetInstall = process.env.VET_AND_INSTALL_OUTPUTS_CHANGES_MADE === 'true';

            if (!artifactDownloadSucceeded) {
                 commentBody += "No dependency information artifact found from the validation workflow, or download failed. No actions taken.\n";
            } else if (!artifactWasValid) { 
                 commentBody += "Dependency artifact was downloaded but found to be empty or invalid by the check step. No actions taken.\n";
            } else { // Artifact was downloaded and deemed valid by check_artifact step
              if (unsafeCount > 0) { 
                commentBody += `ðŸš¨ **Vetting Failed for some dependencies:**\n${unsafeDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed.\n\n`;
              }
              if (manualReviewDetails) {
                commentBody += `âš ï¸ **Dependencies requiring manual review:**\n${manualReviewDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed automatically. Please review their suitability and add them manually if appropriate.\n\n`;
              }
              
              if (changesWereMadeByVetInstall && installedDeps) {
                commentBody += `âœ… **Successfully vetted and installed:** ${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}\nChanges have been pushed to the PR branch. Validation checks will re-run.\n`;
              } else if (!unsafeDetails && !manualReviewDetails && !installedDeps && !changesWereMadeByVetInstall) {
                commentBody += "âœ… All new declared dependencies (if any from artifact) were already present or none required action after vetting. No changes made to package.json by this run.\n";
              } else if (!changesWereMadeByVetInstall && installedDeps && !unsafeDetails && !manualReviewDetails){
                 commentBody += `âœ… Dependencies (${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}) were vetted as safe, but were already in package.json. No changes pushed by this run.\n`;
              } else if (!changesWereMadeByVetInstall && !installedDeps && !unsafeDetails && !manualReviewDetails ){
                  commentBody += "âœ… Dependency artifact processed. No new dependencies required installation, and no issues found with existing identified dependencies.\n";
              }
            }

            commentBody += `\n---\n*This is an automated update from the AI Dependency Manager workflow.*`;

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            } catch (e) {
              core.warning(`Failed to post PR comment: ${e.message}`);
            }

            // Determine job failure based on actual dependency processing from a valid artifact
            if (artifactDownloadSucceeded && artifactWasValid) { // Only consider failure if we had a valid artifact to process
                if (unsafeCount > 0 || manualReviewDetails) { 
                    core.setFailed("One or more dependencies failed vetting or require manual review. See PR comment.");
                }
            }

      - name: Add 'needs-dependency-review' label
        if: steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != '' && steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != null
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.warning("ADM: PR Number not available for adding label. Skipping.");
              return;
            }
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['needs-dependency-review']
            });