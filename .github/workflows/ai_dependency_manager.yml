# .github/workflows/ai-dependency-manager.yml
name: AI Dependency Manager

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR'] # Name of your main PR validation workflow
    types:
      - completed

jobs:
  resolve_dependencies:
    name: Resolve Tool Dependencies
    # Only run if the triggering workflow was for a PR, succeeded or was neutral,
    # AND if it set an output indicating dependency action is needed.
    # This `if` condition will need `validate_generated_tool_pr.yml` to set a specific output.
    # For now, let's assume `validate_generated_tool_pr.yml` will *only* trigger this if needed,
    # for simplicity in this draft, we'll check for a specific artifact.
    if: github.event.workflow_run.conclusion != 'failure' # Example: only run if validate didn't hard fail
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read # To download artifacts
      pull-requests: write # To comment and label

    env:
      # These come from the triggering workflow run event
      PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
      PR_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      PR_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
      VET_DEPENDENCY_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/vet-dependency # Your backend URL

    steps:
      - name: Log Triggering Event Info
        run: |
          echo "Triggered by workflow run: ${{ github.event.workflow_run.id }} for PR #${{ env.PR_NUMBER }}"
          echo "Commit SHA: ${{ env.PR_HEAD_SHA }}"
          echo "Branch: ${{ env.PR_HEAD_BRANCH }}"
          echo "Conclusion of triggering workflow: ${{ github.event.workflow_run.conclusion }}"

      - name: Download Pending Dependencies Artifact
        id: download_pending_deps
        uses: actions/download-artifact@v4
        with:
          name: pending-dependencies-${{ env.PR_HEAD_SHA }} # Artifact name pattern set by validate_... workflow
          path: ${{ runner.temp }}/pending-deps-data
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true # Allow script to check if download succeeded

      - name: Check Artifact and Read Data
        id: check_artifact
        if: steps.download_pending_deps.outcome == 'success'
        run: |
          PENDING_DEPS_FILE="${{ runner.temp }}/pending-deps-data/pending_dependencies.json"
          if [ -f "$PENDING_DEPS_FILE" ] && [ -s "$PENDING_DEPS_FILE" ]; then
            echo "Pending dependencies artifact found and is not empty."
            cat "$PENDING_DEPS_FILE"
            # Further parse with jq if needed here, or pass file path to next step
            echo "artifact_valid=true" >> $GITHUB_OUTPUT
            echo "pending_deps_path=$PENDING_DEPS_FILE" >> $GITHUB_OUTPUT
          else
            echo "::warning::Pending dependencies artifact ($PENDING_DEPS_FILE) not found or empty. No dependencies to process."
            echo "artifact_valid=false" >> $GITHUB_OUTPUT
            # This job might then just complete without error if no artifact, or you could fail it.
            # For now, let's assume it means no action needed.
          fi

      - name: Checkout PR Code
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PR_HEAD_SHA }}
          # GITHUB_TOKEN (default) is fine for checkout

      - name: Vet and Install Dependencies
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        id: vet_and_install
        run: |
          set -e 
          echo "--- Starting: Vet and Install Dependencies ---"
          PENDING_DEPS_FILE="${{ steps.check_artifact.outputs.pending_deps_path }}"
          
          echo "Contents of PENDING_DEPS_FILE ($PENDING_DEPS_FILE):"
          cat "$PENDING_DEPS_FILE" 

          TOOL_DIRECTIVE=$(jq -r '.toolDirective' "$PENDING_DEPS_FILE")
          TOOL_DESCRIPTION=$(jq -r '.toolDescription // "No tool description provided in artifact."' "$PENDING_DEPS_FILE") 
          ASSET_INSTRUCTIONS_FROM_ARTIFACT=$(jq -r '.assetInstructions // ""' "$PENDING_DEPS_FILE")
          
          # Ensure newDependencies is an array, default to empty if not or null
          NEW_DEPENDENCIES_JSON_ARRAY_STR=$(jq -r 'if .newDependencies and (.newDependencies | type == "array") then .newDependencies | tojson else "[]" end' "$PENDING_DEPS_FILE")

          # Temporary files for accumulating lists from the subshell
          VETTED_SAFE_PACKAGES_TMP_FILE=$(mktemp) # Will store packageNames of those provisionally safe
          UNSAFE_DETAILS_TMP_FILE=$(mktemp)     # Stores details of unsafe packages
          MANUAL_REVIEW_TMP_FILE=$(mktemp)  # Stores details of packages needing manual review

          ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="true" # Assume true until a problem is found with any new dependency

          if [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -eq 0 ]; then
            echo "No new dependencies listed in the artifact to vet or install."
            ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" # No deps means no action, but not "all safe" in context of needing to install
          else
            echo "Processing ${NEW_DEPENDENCIES_JSON_ARRAY_STR} for vetting..."
            echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -c '.[]' | while IFS= read -r dep_json; do
              packageName=$(echo "$dep_json" | jq -r '.packageName')
              if [ "$packageName" == "null" ] || [ -z "$packageName" ]; then
                echo "::warning::Skipping dependency with no packageName."
                continue
              fi

              echo "--- Vetting dependency: $packageName for tool $TOOL_DIRECTIVE ---"
              echo "Tool Description for vetting: $TOOL_DESCRIPTION"
              echo "Asset Instructions for vetting (first 100 chars): ${ASSET_INSTRUCTIONS_FROM_ARTIFACT:0:100}..."

              API_PAYLOAD=$(jq -n \
                --arg pkg "$packageName" \
                --arg directive "$TOOL_DIRECTIVE" \
                --arg desc "$TOOL_DESCRIPTION" \
                --arg assetInst "$ASSET_INSTRUCTIONS_FROM_ARTIFACT" \
                '{packageName: $pkg, toolDirective: $directive, toolDescription: $desc, assetInstructions: $assetInst}')
              
              echo "Sending payload to VET_DEPENDENCY_API_ENDPOINT:"
              echo "$API_PAYLOAD"

              HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "${{ env.VET_DEPENDENCY_API_ENDPOINT }}" \
                -H "Content-Type: application/json" \
                -d "$API_PAYLOAD" \
                -o "${{ runner.temp }}/vet_response.json")
              
              echo "Vetting API response for $packageName (HTTP $HTTP_RESPONSE_CODE):"
              cat "${{ runner.temp }}/vet_response.json" 

              if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
                echo "::error::API call to vet $packageName failed (HTTP $HTTP_RESPONSE_CODE)."
                echo "'$packageName' (Vetting API call failed: HTTP $HTTP_RESPONSE_CODE)" >> "$UNSAFE_DETAILS_TMP_FILE"
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"
                continue 
              fi

              vetting_success=$(jq -r .success "${{ runner.temp }}/vet_response.json")
              if [ "$vetting_success" != "true" ] || ! jq -e .vettingResult "${{ runner.temp }}/vet_response.json" > /dev/null; then
                  api_message=$(jq -r .message "${{ runner.temp }}/vet_response.json")
                  echo "::error::Vetting API reported failure for $packageName: $api_message"
                  echo "'$packageName' (Vetting API error: $api_message)" >> "$UNSAFE_DETAILS_TMP_FILE"
                  ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"
                  continue
              fi

              isSafeAndRelevant=$(jq -r '.vettingResult.isLikelySafeAndRelevant' "${{ runner.temp }}/vet_response.json")
              makesExternalNetworkCalls=$(jq -r '.vettingResult.makesExternalNetworkCalls' "${{ runner.temp }}/vet_response.json")
              justification=$(jq -r '.vettingResult.justification' "${{ runner.temp }}/vet_response.json")

              echo "Debug: For $packageName -> isSafeAndRelevant='${isSafeAndRelevant}', makesExternalNetworkCalls='${makesExternalNetworkCalls}'"

              if [ "$isSafeAndRelevant" = "true" ] && [ "$makesExternalNetworkCalls" = "no" ]; then
                echo "$packageName" >> "$VETTED_SAFE_PACKAGES_TMP_FILE" # Add packageName to temp file
                echo "$packageName deemed provisionally safe by vetting API."
              elif [ "$makesExternalNetworkCalls" = "yes" ]; then
                echo "'$packageName' (Reason: Makes external network calls. Justification: $justification)" >> "$UNSAFE_DETAILS_TMP_FILE"
                echo "::error::$packageName flagged by vetting as making external network calls."
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              else 
                echo "'$packageName' (Reason: Needs review. Vetting - Safe: $isSafeAndRelevant, Network: $makesExternalNetworkCalls. Justification: $justification)" >> "$MANUAL_REVIEW_TMP_FILE"
                echo "::warning::$packageName flagged for manual review by vetting API."
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              fi
            done # End of while loop for vetting each dependency
          fi # End of if new dependencies exist in artifact

          # --- Process accumulated results after the loop ---
          mapfile -t provisionally_safe_packages < "$VETTED_SAFE_PACKAGES_TMP_FILE"
          mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE"
          mapfile -t manual_review_package_details < "$MANUAL_REVIEW_TMP_FILE"

          changes_made_to_package_json=false
          packages_actually_installed_this_run=()

          if [ "$ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT" = "true" ] && [ ${#provisionally_safe_packages[@]} -gt 0 ]; then
            echo "All identified new dependencies were vetted as safe. Checking against package.json for installation..."
            packages_to_npm_install=()
            for pkg_name in "${provisionally_safe_packages[@]}"; do
                if ! grep -q "\"$pkg_name\"" package.json; then
                    packages_to_npm_install+=("$pkg_name")
                else
                    echo "Dependency '$pkg_name' already found in package.json, skipping npm install for it."
                fi
            done
            
            if [ ${#packages_to_npm_install[@]} -gt 0 ]; then
                echo "Attempting to install: ${packages_to_npm_install[*]}"
                if npm install "${packages_to_npm_install[@]}" --save; then
                    echo "Successfully installed: ${packages_to_npm_install[*]}"
                    changes_made_to_package_json=true
                    packages_actually_installed_this_run=("${packages_to_npm_install[@]}")
                else
                    echo "::error::'npm install' command failed for some packages: ${packages_to_npm_install[*]}"
                    # Add these to unsafe/manual review as install failed
                    for pkg_failed in "${packages_to_npm_install[@]}"; do
                         echo "'$pkg_failed' (npm install command failed)" >> "$UNSAFE_DETAILS_TMP_FILE"
                    done
                    mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE" # Re-read
                    ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" # Mark as not fully successful
                fi
            else
                echo "No new dependencies needed npm install (all vetted safe ones were already present in package.json)."
            fi
          elif [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -gt 0 ]; then
            # This means there were dependencies, but not ALL were safe.
            echo "Not all dependencies were vetted as safe, or some failed vetting. No dependencies will be installed automatically by this run."
          else
            # This means the newDependencies array in the artifact was empty from the start.
            echo "No new dependencies were identified in the artifact. No installation action taken."
          fi
          
          # Cleanup temp files
          rm "$VETTED_SAFE_PACKAGES_TMP_FILE" "$UNSAFE_DETAILS_TMP_FILE" "$MANUAL_REVIEW_TMP_FILE"

          # Set outputs for subsequent steps (like commit/push and PR comment)
          echo "changes_made=$changes_made_to_package_json" >> $GITHUB_OUTPUT
          echo "unsafe_deps_count=${#unsafe_package_details[@]}" >> $GITHUB_OUTPUT
          
          UNSAFE_DETAILS_STR=$(IFS=$'\n'; echo "${unsafe_package_details[*]}")
          MANUAL_REVIEW_DETAILS_STR=$(IFS=$'\n'; echo "${manual_review_package_details[*]}")
          INSTALLED_DEPS_STR=$(IFS=' '; echo "${packages_actually_installed_this_run[*]}")

          echo "UNSAFE_DEPS_DETAILS<<EOF_UNSAFE" >> $GITHUB_ENV
          echo "$UNSAFE_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_UNSAFE" >> $GITHUB_ENV

          echo "MANUAL_REVIEW_DEPS_DETAILS<<EOF_MANUAL" >> $GITHUB_ENV
          echo "$MANUAL_REVIEW_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_MANUAL" >> $GITHUB_ENV
          
          echo "INSTALLED_DEPS_LIST=$INSTALLED_DEPS_STR" >> $GITHUB_ENV
          echo "--- Finished: Vet and Install Dependencies ---"

      - name: Commit and Push Dependency Changes
        if: steps.vet_and_install.outputs.changes_made == 'true'
        env:
          # Use a PAT that can trigger workflows if needed, or GITHUB_TOKEN if it's configured for that.
          # For pushing to PR branches opened by others, a PAT is usually safer.
          # GITHUB_TOKEN can push to PR branches originating from the same repo.
          GITHUB_TOKEN_FOR_PUSH: ${{ secrets.AI_LINT_FIXER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "OET Dependency Bot"
          git config --global user.email "bot@online-everything-tool.com" # Or your bot's email
          git add package.json package-lock.json
          COMMIT_MSG="chore: add auto-vetted dependencies"
          if [ -n "$INSTALLED_DEPS_LIST" ]; then # From previous step env var
            COMMIT_MSG="chore: add auto-vetted dependencies ($INSTALLED_DEPS_LIST)"
          fi
          git commit -m "$COMMIT_MSG"

          echo "Pushing dependency changes to branch ${{ env.PR_HEAD_BRANCH }}..."
          git push https://x-access-token:${GITHUB_TOKEN_FOR_PUSH}@github.com/${{ github.repository }}.git HEAD:${{ env.PR_HEAD_BRANCH }}

      - name: Post Summary Comment to PR
        uses: actions/github-script@v7
        if: always() # Post comment regardless of previous step failures, to inform user
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN can comment
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.setFailed("PR Number not available for commenting.");
              return;
            }

            let commentBody = `## ðŸ¤– AI Dependency Manager Results for PR #${prNumber}\n\n`;
            const unsafeCount = parseInt(process.env.unsafe_deps_count || "0");
            const installedDeps = process.env.INSTALLED_DEPS_LIST || "";
            const unsafeDetails = process.env.UNSAFE_DEPS_DETAILS || "";
            const manualReviewDetails = process.env.MANUAL_REVIEW_DEPS_DETAILS || "";

            if (process.env.steps_check_artifact_outputs_artifact_valid !== 'true') {
                commentBody += "No dependency information found from the validation workflow. No actions taken.\n";
            } else {
              if (unsafeCount > 0) {
                commentBody += `ðŸš¨ **Vetting Failed for some dependencies:**\n${unsafeDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed.\n\n`;
              }
              if (manualReviewDetails) {
                commentBody += `âš ï¸ **Dependencies requiring manual review:**\n${manualReviewDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed automatically. Please review their suitability and add them manually if appropriate.\n\n`;
              }
              if (process.env.steps_vet_and_install_outputs_changes_made === 'true' && installedDeps) {
                commentBody += `âœ… **Successfully vetted and installed:** ${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}\nChanges have been pushed to the PR branch. Validation checks will re-run.\n`;
              } else if (!unsafeDetails && !manualReviewDetails && !installedDeps) {
                commentBody += "âœ… All new declared dependencies (if any) were already present or none required action after vetting.\n";
              } else if (process.env.steps_vet_and_install_outputs_changes_made !== 'true' && installedDeps && !unsafeDetails && !manualReviewDetails){
                 commentBody += `âœ… Dependencies (${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}) were vetted as safe, but were already in package.json. No changes pushed.\n`;
              }
            }

            commentBody += `\n---\n*This is an automated update from the AI Dependency Manager workflow.*`;

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            } catch (e) {
              core.warning(`Failed to post PR comment: ${e.message}`);
            }

            // If there were unsafe or manual review dependencies, fail this workflow check
            if (unsafeCount > 0 || manualReviewDetails) {
              core.setFailed("One or more dependencies failed vetting or require manual review. See PR comment.");
            }

      - name: Add 'needs-dependency-review' label
        if: steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != '' && steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != null
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} # Needs PAT to add labels typically
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ env.PR_NUMBER }},
              labels: ['needs-dependency-review']
            });
