# .github/workflows/ai_dependency_manager.yml
name: AI Dependency Manager

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR'] # Name of your main PR validation workflow
    types:
      - completed

jobs:
  resolve_dependencies:
    name: Resolve Tool Dependencies
    if: >
      github.event.workflow_run.conclusion != 'failure' &&
      github.event.workflow_run.head_branch != 'main' &&
      github.event.workflow_run.head_branch != github.event.repository.default_branch
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read # To download artifacts
      pull-requests: write # To comment and label

    env:
      # These come from the triggering workflow run event
      PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
      PR_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      PR_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }} # This is github.event.workflow_run.head_branch
      VET_DEPENDENCY_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/vet-dependency 

    steps:
      - name: Log Triggering Event Info
        run: |
          echo "Triggered by workflow run: ${{ github.event.workflow_run.id }} for PR #${{ env.PR_NUMBER }}"
          echo "Commit SHA: ${{ env.PR_HEAD_SHA }}"
          echo "Branch from workflow_run event: ${{ env.PR_HEAD_BRANCH }}"
          echo "Repo default branch: ${{ github.event.repository.default_branch }}"
          echo "Conclusion of triggering workflow: ${{ github.event.workflow_run.conclusion }}"
          # The job-level 'if' condition should prevent this job from running if head_branch is main/default.
          # This log is just for verification if it ever does run when it shouldn't.
          if [ "${{ env.PR_HEAD_BRANCH }}" == "${{ github.event.repository.default_branch }}" ]; then
            echo "::warning::This job is running but PR_HEAD_BRANCH ('${{ env.PR_HEAD_BRANCH }}') is the default branch. This might be unexpected."
          fi

      - name: Download Pending Dependencies Artifact
        id: download_pending_deps
        uses: actions/download-artifact@v4
        with:
          name: pending-dependencies-${{ env.PR_HEAD_SHA }} # Artifact name pattern set by validate_... workflow
          path: ${{ runner.temp }}/pending-deps-data
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true 

      - name: Check Artifact and Read Data
        id: check_artifact
        if: steps.download_pending_deps.outcome == 'success'
        run: |
          PENDING_DEPS_FILE="${{ runner.temp }}/pending-deps-data/pending_dependencies.json"
          if [ -f "$PENDING_DEPS_FILE" ] && [ -s "$PENDING_DEPS_FILE" ]; then
            echo "Pending dependencies artifact found and is not empty."
            cat "$PENDING_DEPS_FILE"
            echo "artifact_valid=true" >> $GITHUB_OUTPUT
            echo "pending_deps_path=$PENDING_DEPS_FILE" >> $GITHUB_OUTPUT
          else
            echo "::notice::Pending dependencies artifact ($PENDING_DEPS_FILE) not found or empty. No dependencies to process for this run."
            echo "artifact_valid=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout PR Code
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PR_HEAD_SHA }}
          # GITHUB_TOKEN (default) is fine for checkout

      - name: Vet and Install Dependencies
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        id: vet_and_install
        run: |
          set -e 
          echo "--- Starting: Vet and Install Dependencies ---"
          PENDING_DEPS_FILE="${{ steps.check_artifact.outputs.pending_deps_path }}"
          
          echo "Contents of PENDING_DEPS_FILE ($PENDING_DEPS_FILE):"
          cat "$PENDING_DEPS_FILE" 

          TOOL_DIRECTIVE=$(jq -r '.toolDirective' "$PENDING_DEPS_FILE")
          TOOL_DESCRIPTION=$(jq -r '.toolDescription // "No tool description provided in artifact."' "$PENDING_DEPS_FILE") 
          ASSET_INSTRUCTIONS_FROM_ARTIFACT=$(jq -r '.assetInstructions // ""' "$PENDING_DEPS_FILE")
          
          NEW_DEPENDENCIES_JSON_ARRAY_STR=$(jq -r 'if .newDependencies and (.newDependencies | type == "array") then .newDependencies | tojson else "[]" end' "$PENDING_DEPS_FILE")

          VETTED_SAFE_PACKAGES_TMP_FILE=$(mktemp) 
          UNSAFE_DETAILS_TMP_FILE=$(mktemp)     
          MANUAL_REVIEW_TMP_FILE=$(mktemp)  

          ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="true" 

          if [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -eq 0 ]; then
            echo "No new dependencies listed in the artifact to vet or install."
            ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
          else
            echo "Processing ${NEW_DEPENDENCIES_JSON_ARRAY_STR} for vetting..."
            echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -c '.[]' | while IFS= read -r dep_json; do
              packageName=$(echo "$dep_json" | jq -r '.packageName')
              if [ "$packageName" == "null" ] || [ -z "$packageName" ]; then
                echo "::warning::Skipping dependency with no packageName."
                continue
              fi

              echo "--- Vetting dependency: $packageName for tool $TOOL_DIRECTIVE ---"
              echo "Tool Description for vetting: $TOOL_DESCRIPTION"
              echo "Asset Instructions for vetting (first 100 chars): ${ASSET_INSTRUCTIONS_FROM_ARTIFACT:0:100}..."

              API_PAYLOAD=$(jq -n \
                --arg pkg "$packageName" \
                --arg directive "$TOOL_DIRECTIVE" \
                --arg desc "$TOOL_DESCRIPTION" \
                --arg assetInst "$ASSET_INSTRUCTIONS_FROM_ARTIFACT" \
                '{packageName: $pkg, toolDirective: $directive, toolDescription: $desc, assetInstructions: $assetInst}')
              
              echo "Sending payload to VET_DEPENDENCY_API_ENDPOINT:"
              echo "$API_PAYLOAD"

              HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "${{ env.VET_DEPENDENCY_API_ENDPOINT }}" \
                -H "Content-Type: application/json" \
                -d "$API_PAYLOAD" \
                -o "${{ runner.temp }}/vet_response.json")
              
              echo "Vetting API response for $packageName (HTTP $HTTP_RESPONSE_CODE):"
              cat "${{ runner.temp }}/vet_response.json" 

              if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
                echo "::error::API call to vet $packageName failed (HTTP $HTTP_RESPONSE_CODE)."
                echo "'$packageName' (Vetting API call failed: HTTP $HTTP_RESPONSE_CODE)" >> "$UNSAFE_DETAILS_TMP_FILE"
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"
                continue 
              fi

              vetting_success=$(jq -r .success "${{ runner.temp }}/vet_response.json")
              if [ "$vetting_success" != "true" ] || ! jq -e .vettingResult "${{ runner.temp }}/vet_response.json" > /dev/null; then
                  api_message=$(jq -r .message "${{ runner.temp }}/vet_response.json")
                  echo "::error::Vetting API reported failure for $packageName: $api_message"
                  echo "'$packageName' (Vetting API error: $api_message)" >> "$UNSAFE_DETAILS_TMP_FILE"
                  ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"
                  continue
              fi

              isSafeAndRelevant=$(jq -r '.vettingResult.isLikelySafeAndRelevant' "${{ runner.temp }}/vet_response.json")
              makesExternalNetworkCalls=$(jq -r '.vettingResult.makesExternalNetworkCalls' "${{ runner.temp }}/vet_response.json")
              justification=$(jq -r '.vettingResult.justification' "${{ runner.temp }}/vet_response.json")

              echo "Debug: For $packageName -> isSafeAndRelevant='${isSafeAndRelevant}', makesExternalNetworkCalls='${makesExternalNetworkCalls}'"

              if [ "$isSafeAndRelevant" = "true" ] && [ "$makesExternalNetworkCalls" = "no" ]; then
                echo "$packageName" >> "$VETTED_SAFE_PACKAGES_TMP_FILE" 
                echo "$packageName deemed provisionally safe by vetting API."
              elif [ "$makesExternalNetworkCalls" = "yes" ]; then
                echo "'$packageName' (Reason: Makes external network calls. Justification: $justification)" >> "$UNSAFE_DETAILS_TMP_FILE"
                echo "::error::$packageName flagged by vetting as making external network calls."
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              else 
                echo "'$packageName' (Reason: Needs review. Vetting - Safe: $isSafeAndRelevant, Network: $makesExternalNetworkCalls. Justification: $justification)" >> "$MANUAL_REVIEW_TMP_FILE"
                echo "::warning::$packageName flagged for manual review by vetting API."
                ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              fi
            done 
          fi 

          mapfile -t provisionally_safe_packages < "$VETTED_SAFE_PACKAGES_TMP_FILE"
          mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE"
          mapfile -t manual_review_package_details < "$MANUAL_REVIEW_TMP_FILE"

          changes_made_to_package_json=false
          packages_actually_installed_this_run=()

          if [ "$ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT" = "true" ] && [ ${#provisionally_safe_packages[@]} -gt 0 ]; then
            echo "All identified new dependencies were vetted as safe. Checking against package.json for installation..."
            packages_to_npm_install=()
            for pkg_name in "${provisionally_safe_packages[@]}"; do
                if ! grep -q "\"$pkg_name\"" package.json; then
                    packages_to_npm_install+=("$pkg_name")
                else
                    echo "Dependency '$pkg_name' already found in package.json, skipping npm install for it."
                fi
            done
            
            if [ ${#packages_to_npm_install[@]} -gt 0 ]; then
                echo "Attempting to install: ${packages_to_npm_install[*]}"
                # --- IMPORTANT: Determine branch to push to ---
                # If PR_HEAD_BRANCH from workflow_run is default, we should not have gotten here.
                # But as a safeguard, or if we wanted to push to the PR's actual head ref,
                # we might need to fetch it via API if PR_NUMBER is available and reliable.
                # For now, this script assumes PR_HEAD_BRANCH is the correct feature branch if the job runs.
                if npm install "${packages_to_npm_install[@]}" --save; then
                    echo "Successfully installed: ${packages_to_npm_install[*]}"
                    changes_made_to_package_json=true
                    packages_actually_installed_this_run=("${packages_to_npm_install[@]}")
                else
                    echo "::error::'npm install' command failed for some packages: ${packages_to_npm_install[*]}"
                    for pkg_failed in "${packages_to_npm_install[@]}"; do
                         echo "'$pkg_failed' (npm install command failed)" >> "$UNSAFE_DETAILS_TMP_FILE"
                    done
                    mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE" 
                    ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
                fi
            else
                echo "No new dependencies needed npm install (all vetted safe ones were already present in package.json)."
            fi
          elif [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -gt 0 ]; then
            echo "Not all dependencies were vetted as safe, or some failed vetting. No dependencies will be installed automatically by this run."
          else
            echo "No new dependencies were identified in the artifact. No installation action taken."
          fi
          
          rm "$VETTED_SAFE_PACKAGES_TMP_FILE" "$UNSAFE_DETAILS_TMP_FILE" "$MANUAL_REVIEW_TMP_FILE"

          echo "changes_made=$changes_made_to_package_json" >> $GITHUB_OUTPUT
          echo "unsafe_deps_count=${#unsafe_package_details[@]}" >> $GITHUB_OUTPUT
          
          UNSAFE_DETAILS_STR=$(IFS=$'\n'; echo "${unsafe_package_details[*]}")
          MANUAL_REVIEW_DETAILS_STR=$(IFS=$'\n'; echo "${manual_review_package_details[*]}")
          INSTALLED_DEPS_STR=$(IFS=' '; echo "${packages_actually_installed_this_run[*]}")

          echo "UNSAFE_DEPS_DETAILS<<EOF_UNSAFE" >> $GITHUB_ENV
          echo "$UNSAFE_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_UNSAFE" >> $GITHUB_ENV

          echo "MANUAL_REVIEW_DEPS_DETAILS<<EOF_MANUAL" >> $GITHUB_ENV
          echo "$MANUAL_REVIEW_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_MANUAL" >> $GITHUB_ENV
          
          echo "INSTALLED_DEPS_LIST=$INSTALLED_DEPS_STR" >> $GITHUB_ENV
          echo "--- Finished: Vet and Install Dependencies ---"

      - name: Commit and Push Dependency Changes
        if: steps.vet_and_install.outputs.changes_made == 'true'
        env:
          GITHUB_TOKEN_FOR_PUSH: ${{ secrets.AI_LINT_FIXER_PAT }}
          # PR_HEAD_BRANCH_FOR_PUSH is ${{ env.PR_HEAD_BRANCH }} which comes from workflow_run.head_branch
        run: |
          git config --global user.name "OET Dependency Bot"
          git config --global user.email "bot@online-everything-tool.com"
          git add package.json package-lock.json
          COMMIT_MSG="chore: add auto-vetted dependencies"
          if [ -n "$INSTALLED_DEPS_LIST" ]; then 
            COMMIT_MSG="chore: add auto-vetted dependencies ($INSTALLED_DEPS_LIST)"
          fi
          git commit -m "$COMMIT_MSG"

          # env.PR_HEAD_BRANCH here is from github.event.workflow_run.head_branch
          # The job-level 'if' should prevent pushing to main/default.
          echo "Pushing dependency changes to branch ${{ env.PR_HEAD_BRANCH }}..."
          git push https://x-access-token:${GITHUB_TOKEN_FOR_PUSH}@github.com/${{ github.repository }}.git HEAD:${{ env.PR_HEAD_BRANCH }}

      - name: Trigger Re-validation via PR Comment After Dep Push
        # This step needs a reliable PR_NUMBER.
        # The job-level 'if' (head_branch != default_branch) makes it more likely that PR_NUMBER is available
        # from github.event.workflow_run.pull_requests[0].number.
        if: steps.vet_and_install.outputs.changes_made == 'true' 
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.setFailed("ADM: Could not determine PR number for re-validation comment. This might happen if PR context was lost.");
              return;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: '/revalidate-ai-fixes' 
            });
            core.info(`ADM: Posted /revalidate-ai-fixes comment to PR #${prNumber} after dependency changes.`);

      - name: Post Summary Comment to PR
        # This step also needs a reliable PR_NUMBER.
        # The job-level 'if' (head_branch != default_branch) makes it more likely that PR_NUMBER is available.
        uses: actions/github-script@v7
        if: always() 
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            // If job ran, PR_NUMBER should be valid due to the job-level 'if' filtering out 'main' branch runs
            // where PR_NUMBER might be missing from workflow_run.pull_requests
            if (isNaN(prNumber)) {
              core.warning("ADM: PR Number not available for summary comment. This is unexpected if the job ran. Skipping comment.");
              // Do not fail the job here if PR_NUMBER is bad, just skip the comment.
              // The job's success/failure should depend on the actual dependency management.
              return; 
            }

            let commentBody = `## 🤖 AI Dependency Manager Results for PR #${prNumber}\n\n`;
            const unsafeCount = parseInt(process.env.unsafe_deps_count || "0");
            const installedDeps = process.env.INSTALLED_DEPS_LIST || "";
            const unsafeDetails = process.env.UNSAFE_DEPS_DETAILS || "";
            const manualReviewDetails = process.env.MANUAL_REVIEW_DEPS_DETAILS || "";

            // Check artifact_valid from the 'check_artifact' step's output
            // Assuming 'steps.check_artifact.outputs.artifact_valid' is accessible here,
            // though it's better practice to pass outputs explicitly or check outcomes of earlier steps.
            // For simplicity, we'll infer based on other conditions for now.
            const artifactProcessed = process.env.steps_check_artifact_outputs_artifact_valid === 'true';


            if (!artifactProcessed && steps.download_pending_deps.outcome != 'success') {
                 commentBody += "No dependency information artifact found from the validation workflow, or it was empty. No actions taken.\n";
            } else if (!artifactProcessed && steps.download_pending_deps.outcome == 'success' && process.env.steps_check_artifact_outputs_artifact_valid !== 'true') {
                 commentBody += "Dependency artifact was downloaded but found to be empty or invalid. No actions taken.\n";
            }
            else { // Artifact was valid and processed
              if (unsafeCount > 0) {
                commentBody += `🚨 **Vetting Failed for some dependencies:**\n${unsafeDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed.\n\n`;
              }
              if (manualReviewDetails) {
                commentBody += `⚠️ **Dependencies requiring manual review:**\n${manualReviewDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed automatically. Please review their suitability and add them manually if appropriate.\n\n`;
              }
              
              // Check vet_and_install outputs for changes_made
              const changesWereMade = process.env.steps_vet_and_install_outputs_changes_made === 'true';

              if (changesWereMade && installedDeps) {
                commentBody += `✅ **Successfully vetted and installed:** ${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}\nChanges have been pushed to the PR branch. Validation checks will re-run.\n`;
              } else if (!unsafeDetails && !manualReviewDetails && !installedDeps && !changesWereMade) {
                 // This case means artifact was valid, but either no new deps in it, or all already in package.json, and nothing was installed.
                commentBody += "✅ All new declared dependencies (if any from artifact) were already present or none required action after vetting. No changes made to package.json by this run.\n";
              } else if (!changesWereMade && installedDeps && !unsafeDetails && !manualReviewDetails){
                 // This means deps were safe, but already in package.json
                 commentBody += `✅ Dependencies (${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}) were vetted as safe, but were already in package.json. No changes pushed by this run.\n`;
              } else if (!changesWereMade && !installedDeps && !unsafeDetails && !manualReviewDetails && artifactProcessed){
                  commentBody += "✅ Dependency artifact processed. No new dependencies required installation, and no issues found with existing identified dependencies.\n";
              }
            }

            commentBody += `\n---\n*This is an automated update from the AI Dependency Manager workflow.*`;

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            } catch (e) {
              core.warning(`Failed to post PR comment: ${e.message}`);
            }

            // Determine job failure based on actual dependency processing, not comment posting
            if (unsafeCount > 0 || manualReviewDetails) {
              // Only fail if there were actual dependencies to process from a valid artifact
              if (artifactProcessed) {
                 core.setFailed("One or more dependencies failed vetting or require manual review. See PR comment.");
              } else {
                 core.notice("No dependencies processed, but noting unsafe/manual review flags if they were somehow set without an artifact.");
              }
            }
      - name: Add 'needs-dependency-review' label
        if: steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != '' && steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != null
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.warning("ADM: PR Number not available for adding label. Skipping.");
              return;
            }
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['needs-dependency-review']
            });