# .github/workflows/ai_dependency_manager.yml
name: AI Dependency Manager

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR']
    types:
      - completed

jobs:
  resolve_dependencies:
    name: Resolve Tool Dependencies
    if: >
      github.event.workflow_run.conclusion != 'failure' &&
      github.event.workflow_run.pull_requests[0] != null &&
      github.event.workflow_run.pull_requests[0].head.ref != github.event.repository.default_branch
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read 
      pull-requests: write 

    env:
      PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
      PR_HEAD_SHA: ${{ github.event.workflow_run.pull_requests[0].head.sha }}
      PR_HEAD_BRANCH: ${{ github.event.workflow_run.pull_requests[0].head.ref }}
      TRIGGERING_WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }} # ID of VPR
      VET_DEPENDENCY_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/vet-dependency 

    steps:
      - name: Log Effective Context
        run: |
          echo "--- ADM Effective Context from workflow_run event ---"
          echo "Processing for PR #${{ env.PR_NUMBER }}"
          echo "Target Branch for Push: ${{ env.PR_HEAD_BRANCH }}"
          echo "Target Commit SHA for Checkout & Artifact: ${{ env.PR_HEAD_SHA }}"
          echo "Triggering VPR Workflow Run ID: ${{ env.TRIGGERING_WORKFLOW_RUN_ID }}"
          echo "Default repository branch: ${{ github.event.repository.default_branch }}"
          echo "Conclusion of VPR: ${{ github.event.workflow_run.conclusion }}"
          echo "----------------------------------------------------"
          if [ "${{ env.PR_HEAD_BRANCH }}" == "${{ github.event.repository.default_branch }}" ]; then
            echo "::error::ADM: PR_HEAD_BRANCH is the default branch. This job should have been skipped by the job-level 'if'. Exiting."
            exit 1
          fi
          if [ -z "${{ env.PR_HEAD_SHA }}" ]; then
            echo "::error::ADM: PR_HEAD_SHA is empty. Cannot proceed."
            exit 1
          fi

      - name: Download Pending Dependencies Artifact
        id: download_pending_deps
        uses: actions/download-artifact@v4
        with:
          name: pending-dependencies-${{ env.PR_HEAD_SHA }} 
          path: ${{ runner.temp }}/pending-deps-data
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ env.TRIGGERING_WORKFLOW_RUN_ID }} 
        continue-on-error: true 

      - name: Check Artifact and Read Data
        id: check_artifact
        if: steps.download_pending_deps.outcome == 'success'
        run: |
          PENDING_DEPS_FILE="${{ runner.temp }}/pending-deps-data/pending_dependencies.json"
          if [ -f "$PENDING_DEPS_FILE" ] && [ -s "$PENDING_DEPS_FILE" ]; then
            echo "Pending dependencies artifact found and is not empty."
            echo "artifact_valid=true" >> $GITHUB_OUTPUT
            echo "pending_deps_path=$PENDING_DEPS_FILE" >> $GITHUB_OUTPUT
          else
            echo "::notice::Pending dependencies artifact downloaded but was empty/invalid."
            echo "artifact_valid=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout PR Code
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PR_HEAD_SHA }} 
          token: ${{ secrets.AI_LINT_FIXER_PAT }} # <<< USE PAT FOR CHECKOUT

      - name: Vet and Install Dependencies
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        id: vet_and_install
        run: |
          set -e 
          PENDING_DEPS_FILE="${{ steps.check_artifact.outputs.pending_deps_path }}"
          TOOL_DIRECTIVE=$(jq -r '.toolDirective' "$PENDING_DEPS_FILE")
          TOOL_DESCRIPTION=$(jq -r '.toolDescription // "No tool description provided"' "$PENDING_DEPS_FILE") 
          ASSET_INSTRUCTIONS_FROM_ARTIFACT=$(jq -r '.assetInstructions // ""' "$PENDING_DEPS_FILE")
          NEW_DEPENDENCIES_JSON_ARRAY_STR=$(jq -r 'if .newDependencies and (.newDependencies | type == "array") then .newDependencies | tojson else "[]" end' "$PENDING_DEPS_FILE")
          VETTED_SAFE_PACKAGES_TMP_FILE=$(mktemp); UNSAFE_DETAILS_TMP_FILE=$(mktemp); MANUAL_REVIEW_TMP_FILE=$(mktemp)
          ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="true" 
          if [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -eq 0 ]; then
            ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"; echo "No new dependencies in artifact.";
          else
            echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -c '.[]' | while IFS= read -r dep_json; do
              packageName=$(echo "$dep_json" | jq -r '.packageName')
              if [ "$packageName" == "null" ] || [ -z "$packageName" ]; then continue; fi
              API_PAYLOAD=$(jq -n --arg pkg "$packageName" --arg directive "$TOOL_DIRECTIVE" --arg desc "$TOOL_DESCRIPTION" --arg assetInst "$ASSET_INSTRUCTIONS_FROM_ARTIFACT" '{packageName: $pkg, toolDirective: $directive, toolDescription: $desc, assetInstructions: $assetInst}')
              HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "${{ env.VET_DEPENDENCY_API_ENDPOINT }}" -H "Content-Type: application/json" -d "$API_PAYLOAD" -o "${{ runner.temp }}/vet_response.json")
              if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
                echo "'$packageName' (Vetting API call failed: HTTP $HTTP_RESPONSE_CODE)" >> "$UNSAFE_DETAILS_TMP_FILE"; ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"; continue 
              fi
              vetting_success=$(jq -r .success "${{ runner.temp }}/vet_response.json")
              if [ "$vetting_success" != "true" ] || ! jq -e .vettingResult "${{ runner.temp }}/vet_response.json" > /dev/null; then
                  api_message=$(jq -r .message "${{ runner.temp }}/vet_response.json"); echo "'$packageName' (Vetting API error: $api_message)" >> "$UNSAFE_DETAILS_TMP_FILE"; ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false"; continue
              fi
              isSafeAndRelevant=$(jq -r '.vettingResult.isLikelySafeAndRelevant' "${{ runner.temp }}/vet_response.json")
              makesExternalNetworkCalls=$(jq -r '.vettingResult.makesExternalNetworkCalls' "${{ runner.temp }}/vet_response.json")
              justification=$(jq -r '.vettingResult.justification' "${{ runner.temp }}/vet_response.json")
              if [ "$isSafeAndRelevant" = "true" ] && [ "$makesExternalNetworkCalls" = "no" ]; then
                echo "$packageName" >> "$VETTED_SAFE_PACKAGES_TMP_FILE"
              elif [ "$makesExternalNetworkCalls" = "yes" ]; then
                echo "'$packageName' (Reason: Makes external network calls. Justification: $justification)" >> "$UNSAFE_DETAILS_TMP_FILE"; ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              else 
                echo "'$packageName' (Reason: Needs review. Vetting - Safe: $isSafeAndRelevant, Network: $makesExternalNetworkCalls. Justification: $justification)" >> "$MANUAL_REVIEW_TMP_FILE"; ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
              fi
            done 
          fi 
          mapfile -t provisionally_safe_packages < "$VETTED_SAFE_PACKAGES_TMP_FILE"; mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE"; mapfile -t manual_review_package_details < "$MANUAL_REVIEW_TMP_FILE"
          changes_made_to_package_json=false; packages_actually_installed_this_run=()
          if [ "$ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT" = "true" ] && [ ${#provisionally_safe_packages[@]} -gt 0 ]; then
            packages_to_npm_install=(); for pkg_name in "${provisionally_safe_packages[@]}"; do if ! grep -q "\"$pkg_name\"" package.json; then packages_to_npm_install+=("$pkg_name"); fi; done
            if [ ${#packages_to_npm_install[@]} -gt 0 ]; then
                if npm install "${packages_to_npm_install[@]}" --save; then
                    changes_made_to_package_json=true; packages_actually_installed_this_run=("${packages_to_npm_install[@]}")
                else
                    for pkg_failed in "${packages_to_npm_install[@]}"; do echo "'$pkg_failed' (npm install command failed)" >> "$UNSAFE_DETAILS_TMP_FILE"; done
                    mapfile -t unsafe_package_details < "$UNSAFE_DETAILS_TMP_FILE"; ALL_NEW_DEPS_ARE_SAFE_AND_RELEVANT="false" 
                fi
            else echo "No new dependencies needed npm install."; fi
          elif [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -gt 0 ]; then echo "Not all dependencies were safe/relevant."; else echo "No new dependencies in artifact."; fi
          rm "$VETTED_SAFE_PACKAGES_TMP_FILE" "$UNSAFE_DETAILS_TMP_FILE" "$MANUAL_REVIEW_TMP_FILE"
          echo "changes_made=$changes_made_to_package_json" >> $GITHUB_OUTPUT
          echo "unsafe_deps_count=${#unsafe_package_details[@]}" >> $GITHUB_OUTPUT
          UNSAFE_DETAILS_STR=$(IFS=$'\n'; echo "${unsafe_package_details[*]}"); MANUAL_REVIEW_DETAILS_STR=$(IFS=$'\n'; echo "${manual_review_package_details[*]}"); INSTALLED_DEPS_STR=$(IFS=' '; echo "${packages_actually_installed_this_run[*]}")
          echo "UNSAFE_DEPS_DETAILS<<EOF_UNSAFE" >> $GITHUB_ENV; echo "$UNSAFE_DETAILS_STR" >> $GITHUB_ENV; echo "EOF_UNSAFE" >> $GITHUB_ENV
          echo "MANUAL_REVIEW_DEPS_DETAILS<<EOF_MANUAL" >> $GITHUB_ENV; echo "$MANUAL_REVIEW_DETAILS_STR" >> $GITHUB_ENV; echo "EOF_MANUAL" >> $GITHUB_ENV
          echo "INSTALLED_DEPS_LIST=$INSTALLED_DEPS_STR" >> $GITHUB_ENV

      - name: Prepare Outputs for Comment Script
        id: prepare_comment_data
        run: |
          echo "DOWNLOAD_PENDING_DEPS_OUTCOME=${{ steps.download_pending_deps.outcome }}" >> $GITHUB_ENV
          echo "CHECK_ARTIFACT_OUTPUTS_ARTIFACT_VALID=${{ steps.check_artifact.outputs.artifact_valid }}" >> $GITHUB_ENV
          echo "VET_AND_INSTALL_OUTPUTS_CHANGES_MADE=${{ steps.vet_and_install.outputs.changes_made }}" >> $GITHUB_ENV

      - name: Commit and Push Dependency Changes
        if: steps.vet_and_install.outputs.changes_made == 'true'
        env:
          GITHUB_TOKEN_FOR_PUSH: ${{ secrets.AI_LINT_FIXER_PAT }}
        run: |
          git config --global user.name "OET Dependency Bot"
          git config --global user.email "bot@online-everything-tool.com" 
          git add package.json package-lock.json
          COMMIT_MSG="chore: add auto-vetted dependencies"
          if [ -n "$INSTALLED_DEPS_LIST" ]; then 
            COMMIT_MSG="chore: add auto-vetted dependencies ($INSTALLED_DEPS_LIST)"
          fi
          git commit -m "$COMMIT_MSG"
          echo "Pushing dependency changes to branch ${{ env.PR_HEAD_BRANCH }}..."
          git push https://x-access-token:${GITHUB_TOKEN_FOR_PUSH}@github.com/${{ github.repository }}.git HEAD:${{ env.PR_HEAD_BRANCH }}

      # No /revalidate-ai-fixes comment from ADM anymore, VPR triggers on synchronize
      - name: Post Summary Comment to PR
        uses: actions/github-script@v7
        if: always() 
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.warning("ADM: PR Number not available for summary comment. Skipping comment.");
              return; 
            }
            let commentBody = `## 🤖 AI Dependency Manager Results for PR #${prNumber}\n\n`;
            const unsafeCount = parseInt(process.env.unsafe_deps_count || "0"); 
            const installedDeps = process.env.INSTALLED_DEPS_LIST || ""; 
            const unsafeDetails = process.env.UNSAFE_DEPS_DETAILS || ""; 
            const manualReviewDetails = process.env.MANUAL_REVIEW_DEPS_DETAILS || ""; 
            const artifactDownloadSucceeded = process.env.DOWNLOAD_PENDING_DEPS_OUTCOME === 'success';
            const artifactWasValid = process.env.CHECK_ARTIFACT_OUTPUTS_ARTIFACT_VALID === 'true';
            const changesWereMadeByVetInstall = process.env.VET_AND_INSTALL_OUTPUTS_CHANGES_MADE === 'true';

            if (!artifactDownloadSucceeded) {
                 commentBody += "No dependency information artifact found, or download failed. No actions taken.\n";
            } else if (!artifactWasValid) { 
                 commentBody += "Dependency artifact downloaded but was empty/invalid. No actions taken.\n";
            } else { 
              if (unsafeCount > 0) { 
                commentBody += `🚨 **Vetting Failed for some dependencies:**\n${unsafeDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed.\n\n`;
              }
              if (manualReviewDetails) {
                commentBody += `⚠️ **Dependencies requiring manual review:**\n${manualReviewDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed automatically.\n\n`;
              }
              if (changesWereMadeByVetInstall && installedDeps) {
                commentBody += `✅ **Successfully vetted and installed:** ${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}\nChanges have been pushed. Validation checks will re-run.\n`;
              } else if (!unsafeDetails && !manualReviewDetails && !installedDeps && !changesWereMadeByVetInstall) {
                commentBody += "✅ All declared dependencies (if any) were present or none required action. No changes made.\n";
              } else if (!changesWereMadeByVetInstall && installedDeps && !unsafeDetails && !manualReviewDetails){
                 commentBody += `✅ Dependencies (${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}) were vetted safe, but already in package.json. No changes pushed.\n`;
              } else if (!changesWereMadeByVetInstall && !installedDeps && !unsafeDetails && !manualReviewDetails ){
                  commentBody += "✅ Dependency artifact processed. No new dependencies required installation.\n";
              }
            }
            commentBody += `\n---\n*This is an automated update by AI Dependency Manager.*`;
            try {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body: commentBody });
            } catch (e) { core.warning(`Failed to post PR comment: ${e.message}`); }
            if (artifactDownloadSucceeded && artifactWasValid) {
                if (unsafeCount > 0 || manualReviewDetails) { 
                    core.setFailed("One or more dependencies failed vetting or require manual review.");
                }
            }
      - name: Add 'needs-dependency-review' label
        if: steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != '' && steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != null
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} 
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) { core.warning("ADM: PR Number not for label. Skipping."); return; }
            await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, labels: ['needs-dependency-review'] });