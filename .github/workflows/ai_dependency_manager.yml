# .github/workflows/ai-dependency-manager.yml
name: AI Dependency Manager

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR'] # Name of your main PR validation workflow
    types:
      - completed

jobs:
  resolve_dependencies:
    name: Resolve Tool Dependencies
    # Only run if the triggering workflow was for a PR, succeeded or was neutral,
    # AND if it set an output indicating dependency action is needed.
    # This `if` condition will need `validate_generated_tool_pr.yml` to set a specific output.
    # For now, let's assume `validate_generated_tool_pr.yml` will *only* trigger this if needed,
    # for simplicity in this draft, we'll check for a specific artifact.
    if: github.event.workflow_run.conclusion != 'failure' # Example: only run if validate didn't hard fail
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read # To download artifacts
      pull-requests: write # To comment and label

    env:
      # These come from the triggering workflow run event
      PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
      PR_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      PR_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
      VET_DEPENDENCY_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/vet-dependency # Your backend URL

    steps:
      - name: Log Triggering Event Info
        run: |
          echo "Triggered by workflow run: ${{ github.event.workflow_run.id }} for PR #${{ env.PR_NUMBER }}"
          echo "Commit SHA: ${{ env.PR_HEAD_SHA }}"
          echo "Branch: ${{ env.PR_HEAD_BRANCH }}"
          echo "Conclusion of triggering workflow: ${{ github.event.workflow_run.conclusion }}"

      - name: Download Pending Dependencies Artifact
        id: download_pending_deps
        uses: actions/download-artifact@v4
        with:
          name: pending-dependencies-${{ env.PR_HEAD_SHA }} # Artifact name pattern set by validate_... workflow
          path: ${{ runner.temp }}/pending-deps-data
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true # Allow script to check if download succeeded

      - name: Check Artifact and Read Data
        id: check_artifact
        if: steps.download_pending_deps.outcome == 'success'
        run: |
          PENDING_DEPS_FILE="${{ runner.temp }}/pending-deps-data/pending_dependencies.json"
          if [ -f "$PENDING_DEPS_FILE" ] && [ -s "$PENDING_DEPS_FILE" ]; then
            echo "Pending dependencies artifact found and is not empty."
            cat "$PENDING_DEPS_FILE"
            # Further parse with jq if needed here, or pass file path to next step
            echo "artifact_valid=true" >> $GITHUB_OUTPUT
            echo "pending_deps_path=$PENDING_DEPS_FILE" >> $GITHUB_OUTPUT
          else
            echo "::warning::Pending dependencies artifact ($PENDING_DEPS_FILE) not found or empty. No dependencies to process."
            echo "artifact_valid=false" >> $GITHUB_OUTPUT
            # This job might then just complete without error if no artifact, or you could fail it.
            # For now, let's assume it means no action needed.
          fi

      - name: Checkout PR Code
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PR_HEAD_SHA }}
          # GITHUB_TOKEN (default) is fine for checkout

      - name: Vet and Install Dependencies
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        id: vet_and_install
        run: |
          set -e # Exit on error
          PENDING_DEPS_FILE="${{ steps.check_artifact.outputs.pending_deps_path }}"

          echo "Contents of PENDING_DEPS_FILE ($PENDING_DEPS_FILE):"
          cat "$PENDING_DEPS_FILE" # Log the artifact content for debugging

          TOOL_DIRECTIVE=$(jq -r '.toolDirective' "$PENDING_DEPS_FILE")
          # Ensure TOOL_DESCRIPTION is correctly populated in the artifact by V_PR
          TOOL_DESCRIPTION=$(jq -r '.toolDescription // "No tool description provided in artifact."' "$PENDING_DEPS_FILE") 
          # Extract assetInstructions from the artifact
          ASSET_INSTRUCTIONS_FROM_ARTIFACT=$(jq -r '.assetInstructions // ""' "$PENDING_DEPS_FILE")

          # Ensure newDependencies is an array, default to empty if not or null
          NEW_DEPENDENCIES_JSON_ARRAY_STR=$(jq -r 'if .newDependencies and (.newDependencies | type == "array") then .newDependencies | tojson else "[]" end' "$PENDING_DEPS_FILE")

          safe_to_install_list=()
          unsafe_details_list=()
          manual_review_details_list=()
          changes_made_to_package_json=false

          if [ "$(echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -r 'length')" -eq 0 ]; then
            echo "No new dependencies listed in the artifact to vet or install."
          else
            # Iterate over each dependency object
            echo "$NEW_DEPENDENCIES_JSON_ARRAY_STR" | jq -c '.[]' | while IFS= read -r dep_json; do
              packageName=$(echo "$dep_json" | jq -r '.packageName')
              if [ "$packageName" == "null" ] || [ -z "$packageName" ]; then
                echo "::warning::Skipping dependency with no packageName."
                continue
              fi

              echo "--- Vetting dependency: $packageName for tool $TOOL_DIRECTIVE ---"
              echo "Tool Description for vetting: $TOOL_DESCRIPTION"
              echo "Asset Instructions for vetting (first 100 chars): ${ASSET_INSTRUCTIONS_FROM_ARTIFACT:0:100}..."

              # Construct the API payload, now including assetInstructions
              API_PAYLOAD=$(jq -n \
                --arg pkg "$packageName" \
                --arg directive "$TOOL_DIRECTIVE" \
                --arg desc "$TOOL_DESCRIPTION" \
                --arg assetInst "$ASSET_INSTRUCTIONS_FROM_ARTIFACT" \
                '{packageName: $pkg, toolDirective: $directive, toolDescription: $desc, assetInstructions: $assetInst}')
              
              echo "Sending payload to VET_DEPENDENCY_API_ENDPOINT:"
              echo "$API_PAYLOAD"

              HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "${{ env.VET_DEPENDENCY_API_ENDPOINT }}" \
                -H "Content-Type: application/json" \
                -d "$API_PAYLOAD" \
                -o "${{ runner.temp }}/vet_response.json")
              
              echo "Vetting API response for $packageName (HTTP $HTTP_RESPONSE_CODE):"
              cat "${{ runner.temp }}/vet_response.json" # Log response for debugging

              if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
                echo "::error::API call to vet $packageName failed (HTTP $HTTP_RESPONSE_CODE). See response above."
                unsafe_details_list+=("'$packageName' (API call failed: HTTP $HTTP_RESPONSE_CODE)")
                continue 
              fi

              vetting_success=$(jq -r .success "${{ runner.temp }}/vet_response.json")
              if [ "$vetting_success" != "true" ] || ! jq -e .vettingResult "${{ runner.temp }}/vet_response.json" > /dev/null; then
                  api_message=$(jq -r .message "${{ runner.temp }}/vet_response.json")
                  echo "::error::Vetting API reported failure for $packageName: $api_message"
                  unsafe_details_list+=("'$packageName' (Vetting API error: $api_message)")
                  continue
              fi

              isSafeAndRelevant=$(jq -r '.vettingResult.isLikelySafeAndRelevant' "${{ runner.temp }}/vet_response.json")
              makesNetworkCalls=$(jq -r '.vettingResult.makesNetworkCalls' "${{ runner.temp }}/vet_response.json")
              justification=$(jq -r '.vettingResult.justification' "${{ runner.temp }}/vet_response.json")

              echo "Vetting result for $packageName: SafeAndRelevant=$isSafeAndRelevant, NetworkCalls=$makesNetworkCalls"
              echo "Justification: $justification"

              # Adjusted logic: if AI says 'no' to network calls (because it understands local assets plan)
              if [ "$isSafeAndRelevant" = "true" ] && [ "$makesNetworkCalls" = "no" ]; then
                safe_to_install_list+=("$packageName")
                echo "$packageName deemed safe to install."
              elif [ "$makesNetworkCalls" = "yes" ]; then
                unsafe_details_list+=("'$packageName' (Reason: Makes external network calls. Justification: $justification)")
                echo "::error::$packageName flagged as making network calls by vetting API."
              else # unknown network calls, not relevant, or other concerns
                manual_review_details_list+=("'$packageName' (Reason: Needs review. Vetting - Safe: $isSafeAndRelevant, Network: $makesNetworkCalls. Justification: $justification)")
                echo "::warning::$packageName flagged for manual review by vetting API."
              fi
            done
          fi # End of if new dependencies exist

          # --- Perform installations (logic unchanged) ---
          if [ ${#safe_to_install_list[@]} -gt 0 ]; then
            echo "Attempting to install safe dependencies: ${safe_to_install_list[*]}"
            final_deps_to_install=()
            for pkg_name in "${safe_to_install_list[@]}"; do
                if ! grep -q "\"$pkg_name\"" package.json; then
                    final_deps_to_install+=("$pkg_name")
                else
                    echo "Dependency '$pkg_name' already found in package.json, skipping install command for it."
                fi
            done
            
            if [ ${#final_deps_to_install[@]} -gt 0 ]; then
                echo "Actually installing: ${final_deps_to_install[*]}"
                npm install "${final_deps_to_install[@]}" --save 
                changes_made_to_package_json=true
            else
                echo "No new safe dependencies to install (all were already present or none were safe)."
            fi
          fi

          echo "changes_made=$changes_made_to_package_json" >> $GITHUB_OUTPUT
          echo "unsafe_deps_count=${#unsafe_details_list[@]}" >> $GITHUB_OUTPUT

          # Join array elements with a unique delimiter for easier parsing in github-script later
          # Or better, write to files if details are long/complex
          UNSAFE_DETAILS_STR=$(IFS=$'\n'; echo "${unsafe_details_list[*]}")
          MANUAL_REVIEW_DETAILS_STR=$(IFS=$'\n'; echo "${manual_review_details_list[*]}")
          INSTALLED_DEPS_STR=$(IFS=' '; echo "${safe_to_install_list[*]}")

          echo "UNSAFE_DEPS_DETAILS<<EOF_UNSAFE" >> $GITHUB_ENV
          echo "$UNSAFE_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_UNSAFE" >> $GITHUB_ENV

          echo "MANUAL_REVIEW_DEPS_DETAILS<<EOF_MANUAL" >> $GITHUB_ENV
          echo "$MANUAL_REVIEW_DETAILS_STR" >> $GITHUB_ENV
          echo "EOF_MANUAL" >> $GITHUB_ENV

          echo "INSTALLED_DEPS_LIST=$INSTALLED_DEPS_STR" >> $GITHUB_ENV

      - name: Commit and Push Dependency Changes
        if: steps.vet_and_install.outputs.changes_made == 'true'
        env:
          # Use a PAT that can trigger workflows if needed, or GITHUB_TOKEN if it's configured for that.
          # For pushing to PR branches opened by others, a PAT is usually safer.
          # GITHUB_TOKEN can push to PR branches originating from the same repo.
          GITHUB_TOKEN_FOR_PUSH: ${{ secrets.AI_LINT_FIXER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "OET Dependency Bot"
          git config --global user.email "bot@online-everything-tool.com" # Or your bot's email
          git add package.json package-lock.json
          COMMIT_MSG="chore: add auto-vetted dependencies"
          if [ -n "$INSTALLED_DEPS_LIST" ]; then # From previous step env var
            COMMIT_MSG="chore: add auto-vetted dependencies ($INSTALLED_DEPS_LIST)"
          fi
          git commit -m "$COMMIT_MSG"

          echo "Pushing dependency changes to branch ${{ env.PR_HEAD_BRANCH }}..."
          git push https://x-access-token:${GITHUB_TOKEN_FOR_PUSH}@github.com/${{ github.repository }}.git HEAD:${{ env.PR_HEAD_BRANCH }}

      - name: Post Summary Comment to PR
        uses: actions/github-script@v7
        if: always() # Post comment regardless of previous step failures, to inform user
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN can comment
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (isNaN(prNumber)) {
              core.setFailed("PR Number not available for commenting.");
              return;
            }

            let commentBody = `## 🤖 AI Dependency Manager Results for PR #${prNumber}\n\n`;
            const unsafeCount = parseInt(process.env.unsafe_deps_count || "0");
            const installedDeps = process.env.INSTALLED_DEPS_LIST || "";
            const unsafeDetails = process.env.UNSAFE_DEPS_DETAILS || "";
            const manualReviewDetails = process.env.MANUAL_REVIEW_DEPS_DETAILS || "";

            if (process.env.steps_check_artifact_outputs_artifact_valid !== 'true') {
                commentBody += "No dependency information found from the validation workflow. No actions taken.\n";
            } else {
              if (unsafeCount > 0) {
                commentBody += `🚨 **Vetting Failed for some dependencies:**\n${unsafeDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed.\n\n`;
              }
              if (manualReviewDetails) {
                commentBody += `⚠️ **Dependencies requiring manual review:**\n${manualReviewDetails.split(',').map(d => `- ${d.trim()}`).join('\n')}\nThese were NOT installed automatically. Please review their suitability and add them manually if appropriate.\n\n`;
              }
              if (process.env.steps_vet_and_install_outputs_changes_made === 'true' && installedDeps) {
                commentBody += `✅ **Successfully vetted and installed:** ${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}\nChanges have been pushed to the PR branch. Validation checks will re-run.\n`;
              } else if (!unsafeDetails && !manualReviewDetails && !installedDeps) {
                commentBody += "✅ All new declared dependencies (if any) were already present or none required action after vetting.\n";
              } else if (process.env.steps_vet_and_install_outputs_changes_made !== 'true' && installedDeps && !unsafeDetails && !manualReviewDetails){
                 commentBody += `✅ Dependencies (${installedDeps.split(' ').map(d => `\`${d}\``).join(', ')}) were vetted as safe, but were already in package.json. No changes pushed.\n`;
              }
            }

            commentBody += `\n---\n*This is an automated update from the AI Dependency Manager workflow.*`;

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            } catch (e) {
              core.warning(`Failed to post PR comment: ${e.message}`);
            }

            // If there were unsafe or manual review dependencies, fail this workflow check
            if (unsafeCount > 0 || manualReviewDetails) {
              core.setFailed("One or more dependencies failed vetting or require manual review. See PR comment.");
            }

      - name: Add 'needs-dependency-review' label
        if: steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != '' && steps.vet_and_install.outputs.MANUAL_REVIEW_DEPS_DETAILS != null
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AI_LINT_FIXER_PAT }} # Needs PAT to add labels typically
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ env.PR_NUMBER }},
              labels: ['needs-dependency-review']
            });
