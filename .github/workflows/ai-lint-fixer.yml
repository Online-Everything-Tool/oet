# .github/workflows/ai-lint-fixer.yml
name: AI Lint Fixer

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR']
    types:
      - completed

jobs:
  attempt_fix:
    name: Attempt AI Lint Fix
    if: github.event.workflow_run.conclusion == 'failure'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read 
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 

    steps:
      - name: Get Triggering Workflow Run Info & Expected Artifact Details
        id: get_trigger_info
        run: |
          echo "--- Trigger Info ---"
          echo "Triggering Workflow Run ID: ${{ github.event.workflow_run.id }}"
          echo "Expected Artifact SHA (from workflow_run.head_sha): ${{ github.event.workflow_run.head_sha }}"
          echo "Expected Artifact Name: lint-failure-data-${{ github.event.workflow_run.head_sha }}"
          echo "PR Head Branch for push: ${{ github.event.workflow_run.head_branch }}"
          echo "Commit SHA for checkout: ${{ github.event.workflow_run.head_sha }}"
          echo "----------------------"
          echo "EXPECTED_ARTIFACT_SHA=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV
          echo "PR_HEAD_BRANCH_FOR_PUSH=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_ENV

      - name: Retrieve Artifact Download URL via API
        id: get_artifact_url
        uses: actions/github-script@v7
        with:
          script: |
            const run_id = ${{ github.event.workflow_run.id }};
            const expected_artifact_name = "lint-failure-data-${{ github.event.workflow_run.head_sha }}";
            core.info(`Looking for artifact: "${expected_artifact_name}" in workflow run ID: ${run_id}`);
            
            const artifacts_response = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: run_id,
            });

            if (artifacts_response.data.artifacts.length === 0) {
              core.setFailed(`No artifacts found for workflow run ID: ${run_id}`);
              return;
            }
            core.info(`Found ${artifacts_response.data.artifacts.length} artifacts:`);
            let found_artifact_details = null;
            for (const artifact of artifacts_response.data.artifacts) {
              core.info(`- Name: ${artifact.name}, ID: ${artifact.id}, Size: ${artifact.size_in_bytes}`);
              if (artifact.name === expected_artifact_name) {
                found_artifact_details = artifact;
                break;
              }
            }

            if (found_artifact_details) {
              core.info(`MATCH FOUND: Artifact ID: ${found_artifact_details.id}, Download URL available.`);
              core.setOutput('artifact_id', found_artifact_details.id.toString());
              core.setOutput('artifact_download_url', found_artifact_details.archive_download_url);
              core.setOutput('artifact_found_api', 'true');
            } else {
              core.setFailed(`Expected artifact "${expected_artifact_name}" not found among the ${artifacts_response.data.artifacts.length} listed artifacts via API.`);
              core.setOutput('artifact_found_api', 'false');
            }
      
      - name: Download and Extract Artifact Manually
        id: download_and_extract # This step sets 'manual_extraction_complete'
        if: steps.get_artifact_url.outputs.artifact_found_api == 'true'
        run: |
          ARTIFACT_DOWNLOAD_URL="${{ steps.get_artifact_url.outputs.artifact_download_url }}"
          ARTIFACT_DEST_PATH="${{ runner.temp }}/lint-data" 
          ARTIFACT_ZIP_FILE="${{ runner.temp }}/downloaded_artifact.zip"

          echo "Manually downloading artifact using URL: $ARTIFACT_DOWNLOAD_URL"
          mkdir -p "$ARTIFACT_DEST_PATH"
          
          curl --retry 3 --retry-delay 5 -L -o "$ARTIFACT_ZIP_FILE" "$ARTIFACT_DOWNLOAD_URL"
          
          if [ ! -f "$ARTIFACT_ZIP_FILE" ] || [ ! -s "$ARTIFACT_ZIP_FILE" ]; then
            echo "::error::Failed to download artifact zip or zip is empty."
            echo "manual_extraction_complete=false" >> $GITHUB_OUTPUT # Set output on failure
            exit 1
          fi
          
          echo "Artifact zip downloaded. Extracting to $ARTIFACT_DEST_PATH..."
          unzip -q "$ARTIFACT_ZIP_FILE" -d "$ARTIFACT_DEST_PATH"
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to unzip artifact."
            ls -la ${{ runner.temp }} 
            echo "manual_extraction_complete=false" >> $GITHUB_OUTPUT # Set output on failure
            exit 1
          fi
          
          echo "Artifact extracted. Verifying contents..."
          if [ -f "$ARTIFACT_DEST_PATH/lint_errors.txt" ] && [ -f "$ARTIFACT_DEST_PATH/files_to_check.txt" ]; then
            echo "Required files (lint_errors.txt, files_to_check.txt) found in extracted artifact."
            echo "manual_extraction_complete=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Required files not found after extracting artifact."
            echo "Contents of $ARTIFACT_DEST_PATH:"
            ls -la "$ARTIFACT_DEST_PATH" 
            echo "manual_extraction_complete=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # This step was named 'check_artifact' in your file, I renamed it to 'check_artifact_data_validity' for clarity
      # and its 'if' condition is now correct.
      - name: Check Artifact Data Validity
        id: check_artifact_data_validity 
        if: steps.download_and_extract.outputs.manual_extraction_complete == 'true' # Depends on the manual download step
        run: |
          echo "--- Entered Check Artifact Data Validity step ---"
          echo "Condition 'steps.download_and_extract.outputs.manual_extraction_complete == true' was met."
          LINT_ERRORS_FILE="${{ runner.temp }}/lint-data/lint_errors.txt"
          FILES_TO_CHECK_FILE="${{ runner.temp }}/lint-data/files_to_check.txt"

          echo "--- Contents of lint_errors.txt (first 10 lines) ---"
          head -n 10 "$LINT_ERRORS_FILE" || echo "lint_errors.txt not found or head failed"
          echo "--- End lint_errors.txt preview ---"
          echo "--- Contents of files_to_check.txt ---"
          cat "$FILES_TO_CHECK_FILE" || echo "files_to_check.txt not found or cat failed"
          echo "--- End files_to_check.txt ---"
          
          echo "Checking LINT_ERRORS_FILE ($LINT_ERRORS_FILE):"
          if [ -f "$LINT_ERRORS_FILE" ]; then echo "Exists."; else echo "DOES NOT EXIST."; fi
          if [ -s "$LINT_ERRORS_FILE" ]; then echo "Is not empty."; else echo "IS EMPTY or does not exist."; fi
          
          echo "Checking FILES_TO_CHECK_FILE ($FILES_TO_CHECK_FILE):"
          if [ -f "$FILES_TO_CHECK_FILE" ]; then echo "Exists."; else echo "DOES NOT EXIST."; fi
          if [ -s "$FILES_TO_CHECK_FILE" ]; then echo "Is not empty."; else echo "IS EMPTY or does not exist."; fi

          if [ -s "$LINT_ERRORS_FILE" ] && [ -s "$FILES_TO_CHECK_FILE" ]; then
            echo "Manually downloaded artifact files are valid and not empty. Setting artifact_data_valid=true"
            echo "artifact_data_valid=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Manually downloaded artifact files (lint_errors.txt or files_to_check.txt) are missing or empty."
            echo "Setting artifact_data_valid=false"
            echo "artifact_data_valid=false" >> $GITHUB_OUTPUT
            exit 1 
          fi
          echo "--- Exiting Check Artifact Data Validity step ---"          

      - name: Debug Conditions Before Apply and Commit
        if: always() 
        run: |
          echo "--- Debugging Conditions for Apply and Commit Fixes ---"
          echo "1. steps.call_fix_api.outputs.api_call_skipped: [${{ steps.call_fix_api.outputs.api_call_skipped }}]"
          echo "   Condition 'steps.call_fix_api.outputs.api_call_skipped != 'true'' evaluates to: $(if [[ "${{ steps.call_fix_api.outputs.api_call_skipped }}" != "true" ]]; then echo "true"; else echo "false"; fi)"
          
          echo "2. steps.call_fix_api.outputs.api_response_success: [${{ steps.call_fix_api.outputs.api_response_success }}]"
          echo "   Condition 'steps.call_fix_api.outputs.api_response_success == 'true'' evaluates to: $(if [[ "${{ steps.call_fix_api.outputs.api_response_success }}" == "true" ]]; then echo "true"; else echo "false"; fi)"

          # Corrected to use the new step ID 'check_artifact_data_validity'
          echo "3. steps.check_artifact_data_validity.outputs.artifact_data_valid: [${{ steps.check_artifact_data_validity.outputs.artifact_data_valid }}]"
          echo "   Condition 'steps.check_artifact_data_validity.outputs.artifact_data_valid == 'true'' evaluates to: $(if [[ "${{ steps.check_artifact_data_validity.outputs.artifact_data_valid }}" == "true" ]]; then echo "true"; else echo "false"; fi)"
          
          echo "Overall condition for Apply and Commit Fixes should be: $(if [[ "${{ steps.call_fix_api.outputs.api_call_skipped }}" != "true" && "${{ steps.call_fix_api.outputs.api_response_success }}" == "true" && "${{ steps.check_artifact_data_validity.outputs.artifact_data_valid }}" == "true" ]]; then echo "TRUE"; else echo "FALSE"; fi)"
          echo "-----------------------------------------------------"

      - name: Checkout PR Code
        # Corrected to use the new step ID 'check_artifact_data_validity'
        if: steps.check_artifact_data_validity.outputs.artifact_data_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.EXPECTED_ARTIFACT_SHA }} 
          fetch-depth: 0

      - name: Prepare Data for AI Lint Fix API
        id: prepare_fix_data
        # Corrected to use the new step ID 'check_artifact_data_validity'
        if: steps.check_artifact_data_validity.outputs.artifact_data_valid == 'true'
        run: |
          LINT_ERRORS_FILE="${{ runner.temp }}/lint-data/lint_errors.txt"
          FILES_TO_CHECK_FILE="${{ runner.temp }}/lint-data/files_to_check.txt"
          PR_FILES_JSON_PATH="${{ runner.temp }}/pr_files_for_lint_fix.json"

          echo "--- Preparing pr_files_for_lint_fix.json ---"
          echo '[' > $PR_FILES_JSON_PATH
          FIRST_FILE=true
          while IFS= read -r filepath; do
            if [ -z "$filepath" ]; then echo "Skipping empty filepath in files_to_check.txt"; continue; fi
            echo "Processing filepath from artifact: '$filepath'"
            if [ -f "$filepath" ]; then
              if [ "$FIRST_FILE" = "false" ]; then
                echo ',' >> $PR_FILES_JSON_PATH
              fi
              FILE_CONTENT_RAW=$(cat "$filepath")
              echo "First 5 lines of content for '$filepath':"
              echo "$FILE_CONTENT_RAW" | head -n 5 | sed 's/^/    /' 
              jq -n --arg path "$filepath" --arg content "$FILE_CONTENT_RAW" \
                '{path: $path, currentContent: $content}' >> $PR_FILES_JSON_PATH
              FIRST_FILE=false
            else
              echo "::warning::File path '$filepath' from artifact not found in checkout. Skipping."
            fi
          done < "$FILES_TO_CHECK_FILE"
          echo ']' >> $PR_FILES_JSON_PATH
          
          jq -s 'if type == "array" and length > 0 and (.[0] | type) == "array" then .[0] else . end' $PR_FILES_JSON_PATH > temp_final.json && mv temp_final.json $PR_FILES_JSON_PATH
          
          echo "--- Content of prepared pr_files_for_lint_fix.json (first 20 lines) ---"
          head -n 20 $PR_FILES_JSON_PATH
          echo "--- End pr_files_for_lint_fix.json preview ---"
          echo "Full path to prepared JSON: $PR_FILES_JSON_PATH"
          echo "-------------------------------------------"

      - name: Call AI Lint Fix API
        id: call_fix_api
        # Corrected to use the new step ID 'check_artifact_data_validity'
        if: steps.prepare_fix_data.outcome == 'success' && steps.check_artifact_data_validity.outputs.artifact_data_valid == 'true'
        env:
          LINT_FIX_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/fix-linting-errors
        run: |
          LINT_ERRORS_CONTENT=$(cat "${{ runner.temp }}/lint-data/lint_errors.txt")
          LINT_ERRORS_JSON_ESCAPED=$(echo "$LINT_ERRORS_CONTENT" | jq -R -s '.')
          FILES_TO_FIX_JSON_CONTENT=$(cat "${{ runner.temp }}/pr_files_for_lint_fix.json")

          if ! echo "$FILES_TO_FIX_JSON_CONTENT" | jq -e 'type == "array" and length > 0' > /dev/null; then
            echo "::warning::No valid files to fix after preparation (FILES_TO_FIX_JSON_CONTENT is not a non-empty array). Skipping API call."
            echo "Content of pr_files_for_lint_fix.json that caused skip:"
            cat "${{ runner.temp }}/pr_files_for_lint_fix.json" 
            echo "api_call_skipped=true" >> $GITHUB_OUTPUT
            exit 0 
          fi

          API_PAYLOAD=$(jq -n \
            --argjson filesToFix "$FILES_TO_FIX_JSON_CONTENT" \
            --argjson lintErrors "$LINT_ERRORS_JSON_ESCAPED" \
            --arg modelName "models/gemini-1.5-pro-latest" \
            '{filesToFix: $filesToFix, lintErrors: $lintErrors, modelName: $modelName}')

          echo "Calling AI Lint Fix API at $LINT_FIX_API_ENDPOINT ..."
          echo "API Payload (first 500 chars): $(echo "$API_PAYLOAD" | head -c 500)" 
          
          HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "$LINT_FIX_API_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "$API_PAYLOAD" \
            -o "${{ runner.temp }}/fix_response.json")

          echo "AI Lint Fix API HTTP Status: $HTTP_RESPONSE_CODE"
          echo "--- AI API Response (fix_response.json) ---"
          cat "${{ runner.temp }}/fix_response.json"
          echo "--- End AI API Response ---"

          if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
            echo "::error::AI Lint Fix API call failed with HTTP status $HTTP_RESPONSE_CODE."
            exit 1
          fi

          if ! jq -e . "${{ runner.temp }}/fix_response.json" > /dev/null 2>&1; then
            echo "::error::AI Lint Fix API response is not valid JSON."
            exit 1
          fi
          
          FIX_API_SUCCESS=$(jq -r .success "${{ runner.temp }}/fix_response.json")
          echo "Fix API Reported Success (from JSON): $FIX_API_SUCCESS"
          echo "api_response_success=$FIX_API_SUCCESS" >> $GITHUB_OUTPUT
          echo "api_response_path=${{ runner.temp }}/fix_response.json" >> $GITHUB_OUTPUT
          echo "api_call_skipped=false" >> $GITHUB_OUTPUT
          
      - name: Apply and Commit Fixes
        # Corrected to use the new step ID 'check_artifact_data_validity'
        if: steps.call_fix_api.outputs.api_call_skipped != 'true' && steps.call_fix_api.outputs.api_response_success == 'true' && steps.check_artifact_data_validity.outputs.artifact_data_valid == 'true'
        run: |
          echo "--- Starting Apply and Commit Fixes ---"
          FIX_RESPONSE_FILE="${{ steps.call_fix_api.outputs.api_response_path }}"
          echo "Applying fixes from $FIX_RESPONSE_FILE..."
          
          LAST_COMMIT_MSG_ON_BRANCH=$(git log -1 --pretty=%B)
          echo "Last commit message on branch: $LAST_COMMIT_MSG_ON_BRANCH"

          if [[ "$LAST_COMMIT_MSG_ON_BRANCH" == "chore: AI-assisted lint fixes" ]]; then
            echo "::warning::The latest commit on the branch is already an AI lint fix. Skipping."
            exit 0 
          fi

          CHANGES_APPLIED_FLAG_FILE=$(mktemp)
          echo "false" > "$CHANGES_APPLIED_FLAG_FILE"
          
          echo "--- Attempting to extract file paths from API response ---"
          set +e 
          FILE_PATHS_TO_PROCESS_OUTPUT=$(jq -r '.fixedFiles | to_entries[] | select(.value != null) | .key' "$FIX_RESPONSE_FILE")
          JQ_EXIT_CODE=$?
          set -e

          echo "JQ exit code for extracting paths: $JQ_EXIT_CODE"
          echo "Raw output from JQ for FILE_PATHS_TO_PROCESS_OUTPUT (before assigning to var):"
          echo "$FILE_PATHS_TO_PROCESS_OUTPUT"
          echo "--- End Raw JQ Output ---"

          FILE_PATHS_TO_PROCESS="$FILE_PATHS_TO_PROCESS_OUTPUT" 

          if [ "$JQ_EXIT_CODE" -ne 0 ]; then
            echo "::error:: jq command failed to extract file paths. Cannot apply fixes."
            echo "Contents of $FIX_RESPONSE_FILE that caused jq error:"
            cat "$FIX_RESPONSE_FILE"
            exit 1 
          fi

          if [ -z "$FILE_PATHS_TO_PROCESS" ]; then
            echo "::notice::No files with non-null fixed content found in API response (FILE_PATHS_TO_PROCESS is empty)."
          else
            echo "File paths to process (after assignment, one per line expected):"
            echo "$FILE_PATHS_TO_PROCESS"
            echo "--- Processing each file path ---"

            echo "$FILE_PATHS_TO_PROCESS" | while IFS= read -r filepath; do # Changed to pipe for the loop
              if [ -z "$filepath" ]; then
                echo "::warning::Empty filepath encountered in loop. Skipping."
                continue
              fi
              echo "Processing filepath from loop: '$filepath'"

              fixedcontent=$(jq -r --arg pathkey "$filepath" '.fixedFiles[$pathkey]' "$FIX_RESPONSE_FILE")

              if [ "$fixedcontent" = "null" ] || [ -z "$fixedcontent" ]; then
                echo "::warning::Content for '$filepath' is null or empty in the API response (second check). Skipping."
                continue
              fi

              if [ ! -f "$filepath" ]; then 
                echo "::warning::File '$filepath' from API response not found in local checkout. Skipping."
                continue
              fi
              
              echo "--- Original Content for '$filepath' (first 10 lines) ---"
              head -n 10 "$filepath" | sed 's/^/    /' 
              echo "--- End Original Content Preview ---"
              echo "--- AI Fixed Content for '$filepath' (first 10 lines) ---"
              echo "$fixedcontent" | head -n 10 | sed 's/^/    /' 
              echo "--- End AI Fixed Content Preview ---"

              ORIGINAL_CONTENT_FOR_COMPARE=$(cat "$filepath")
              NORMALIZED_ORIGINAL_CONTENT=$(echo "$ORIGINAL_CONTENT_FOR_COMPARE" | tr -d '\r')
              NORMALIZED_FIXED_CONTENT=$(echo "$fixedcontent" | tr -d '\r')

              if [ "$NORMALIZED_ORIGINAL_CONTENT" = "$NORMALIZED_FIXED_CONTENT" ]; then
                echo "No actual content change (ignoring line endings) for '$filepath'. Skipping add."
              else
                echo "CONTENT DIFFERS for '$filepath'. Applying fix."
                echo "Overwriting '$filepath' with AI content."
                echo "$fixedcontent" > "$filepath" 
                git add "$filepath"
                echo "'$filepath' added to git staging area."
                echo "true" > "$CHANGES_APPLIED_FLAG_FILE" 
              fi
            done 
          fi 
          
          CHANGES_APPLIED=$(cat "$CHANGES_APPLIED_FLAG_FILE")
          rm "$CHANGES_APPLIED_FLAG_FILE" 

          echo "CHANGES_APPLIED flag (read from file) is: $CHANGES_APPLIED"

          if [ "$CHANGES_APPLIED" = "true" ]; then
            echo "Changes were applied. Checking staged diff..."
            if ! git diff --staged --quiet; then
              echo "Staged changes found. Proceeding with commit and push."
              git config user.name "OET Bot" 
              git config user.email "bot@online-everything-tool.com" 
              git commit -m "chore: AI-assisted lint fixes"
              git push origin HEAD:${{ env.PR_HEAD_BRANCH_FOR_PUSH }} 
              echo "::notice::AI lint fixes committed and pushed. Workflow on PR branch will re-run."
            else
              echo "::notice::AI proposed changes, but 'git diff --staged --quiet' found no differences after 'git add'."
            fi
          else
            echo "::notice::No changes were applied by the AI, or all changes resulted in identical content (after normalization)."
          fi
          echo "--- End of Apply and Commit Fixes ---"