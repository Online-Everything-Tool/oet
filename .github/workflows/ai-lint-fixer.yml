# .github/workflows/ai-lint-fixer.yml
name: AI Lint Fixer

on:
  workflow_run:
    workflows: ['Validate Generated Tool PR']
    types:
      - completed

jobs:
  attempt_fix:
    name: Attempt AI Lint Fix
    if: github.event.workflow_run.conclusion == 'failure'
    runs-on: ubuntu-latest
    permissions:
      contents: write # For checkout
      actions: read   # For downloading artifacts
    env:
      EXPECTED_ARTIFACT_SHA: ${{ github.event.workflow_run.head_sha }}
      PR_HEAD_BRANCH_FOR_PUSH: ${{ github.event.workflow_run.head_branch }}

    steps:
      - name: Get Triggering Workflow Run Info
        id: get_trigger_info
        run: |
          echo "--- Trigger Info ---"
          echo "Triggering Workflow Run ID: ${{ github.event.workflow_run.id }}"
          echo "Expected Artifact Name: lint-failure-data-${{ env.EXPECTED_ARTIFACT_SHA }}"
          echo "PR Head Branch for push: ${{ env.PR_HEAD_BRANCH_FOR_PUSH }}"
          echo "Commit SHA for checkout: ${{ env.EXPECTED_ARTIFACT_SHA }}"
          echo "----------------------"

      - name: Download Lint Failure Artifact
        id: download_artifact
        uses: actions/download-artifact@v4
        with:
          name: lint-failure-data-${{ env.EXPECTED_ARTIFACT_SHA }}
          path: ${{ runner.temp }}/lint-data
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true

      - name: Check if Artifact Exists and Contains Data
        id: check_artifact
        if: steps.download_artifact.outcome == 'success'
        run: |
          LINT_ERRORS_FILE="${{ runner.temp }}/lint-data/lint_errors.txt"
          FILES_TO_CHECK_FILE="${{ runner.temp }}/lint-data/files_to_check.txt"
          echo "--- Artifact Download and Content Check ---"
          echo "Download artifact step outcome: ${{ steps.download_artifact.outcome }}"
          echo "Checking for file: $LINT_ERRORS_FILE"
          ls -la "${{ runner.temp }}/lint-data/"
          if [ -f "$LINT_ERRORS_FILE" ] && [ -s "$LINT_ERRORS_FILE" ] && \
             [ -f "$FILES_TO_CHECK_FILE" ] && [ -s "$FILES_TO_CHECK_FILE" ]; then
            echo "Lint failure artifacts found and are not empty."
            echo "artifact_valid=true" >> $GITHUB_OUTPUT
            echo "--- Contents of lint_errors.txt (first 10 lines) ---"
            head -n 10 "$LINT_ERRORS_FILE"
            echo "--- End lint_errors.txt preview ---"
            echo "--- Contents of files_to_check.txt ---"
            cat "$FILES_TO_CHECK_FILE"
            echo "--- End files_to_check.txt ---"
          else
            echo "::error::Lint failure artifact files (lint_errors.txt or files_to_check.txt) not found or empty after download attempt."
            echo "artifact_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "-------------------------------------------"

      - name: Checkout PR Code
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.EXPECTED_ARTIFACT_SHA }}
          fetch-depth: 0 # Important for getting the correct last commit message

      - name: Prepare Data for AI Lint Fix API
        id: prepare_fix_data
        if: steps.check_artifact.outputs.artifact_valid == 'true'
        run: |
          LINT_ERRORS_FILE="${{ runner.temp }}/lint-data/lint_errors.txt"
          FILES_TO_CHECK_FILE="${{ runner.temp }}/lint-data/files_to_check.txt"
          PR_FILES_JSON_PATH="${{ runner.temp }}/pr_files_for_lint_fix.json"
          echo "--- Preparing pr_files_for_lint_fix.json ---"
          echo '[' > $PR_FILES_JSON_PATH
          FIRST_FILE=true
          while IFS= read -r filepath; do
            if [ -z "$filepath" ]; then echo "Skipping empty filepath in files_to_check.txt"; continue; fi
            echo "Processing filepath from artifact: '$filepath'"
            if [ -f "$filepath" ]; then
              if [ "$FIRST_FILE" = "false" ]; then
                echo ',' >> $PR_FILES_JSON_PATH
              fi
              FILE_CONTENT_RAW=$(cat "$filepath")
              jq -n --arg path "$filepath" --arg content "$FILE_CONTENT_RAW" \
                '{path: $path, currentContent: $content}' >> $PR_FILES_JSON_PATH
              FIRST_FILE=false
            else
              echo "::warning::File path '$filepath' from artifact not found in checkout. Skipping."
            fi
          done < "$FILES_TO_CHECK_FILE"
          echo ']' >> $PR_FILES_JSON_PATH
          # Ensure valid JSON array even if only one item (or handle empty array if needed)
          jq -s 'if type == "array" and length > 0 and (.[0] | type) == "array" then .[0] else . end' $PR_FILES_JSON_PATH > temp_final.json && mv temp_final.json $PR_FILES_JSON_PATH
          echo "Full path to prepared JSON: $PR_FILES_JSON_PATH"
          echo "-------------------------------------------"

      - name: Call AI Lint Fix API
        id: call_fix_api
        if: steps.prepare_fix_data.outcome == 'success' && steps.check_artifact.outputs.artifact_valid == 'true'
        env:
          LINT_FIX_API_ENDPOINT: ${{ secrets.BACKEND_APP_URL }}/api/fix-linting-errors
        run: |
          LINT_ERRORS_CONTENT=$(cat "${{ runner.temp }}/lint-data/lint_errors.txt")
          LINT_ERRORS_JSON_ESCAPED=$(echo "$LINT_ERRORS_CONTENT" | jq -R -s '.')
          FILES_TO_FIX_JSON_CONTENT=$(cat "${{ runner.temp }}/pr_files_for_lint_fix.json")

          if ! echo "$FILES_TO_FIX_JSON_CONTENT" | jq -e 'type == "array" and length > 0' > /dev/null; then
            echo "::warning::No valid files to fix after preparation (JSON array is empty or not an array). Skipping API call."
            echo "api_call_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          API_PAYLOAD=$(jq -n \
            --argjson filesToFix "$FILES_TO_FIX_JSON_CONTENT" \
            --argjson lintErrors "$LINT_ERRORS_JSON_ESCAPED" \
            --arg modelName "models/gemini-1.5-pro-latest" \
            '{filesToFix: $filesToFix, lintErrors: $lintErrors, modelName: $modelName}')

          echo "Calling AI Lint Fix API at $LINT_FIX_API_ENDPOINT ..."

          HTTP_RESPONSE_CODE=$(curl -s -w "%{http_code}" -X POST "$LINT_FIX_API_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "$API_PAYLOAD" \
            -o "${{ runner.temp }}/fix_response.json")

          echo "AI Lint Fix API HTTP Status: $HTTP_RESPONSE_CODE"
      
          echo "--- AI API Response (fix_response.json) ---"
          cat "${{ runner.temp }}/fix_response.json"
          echo "--- End AI API Response ---"

          if [ "$HTTP_RESPONSE_CODE" -ne 200 ]; then
            echo "::error::AI Lint Fix API call failed with HTTP status $HTTP_RESPONSE_CODE."
            # Consider logging parts of the response if safe, or just the presence of an error field
            # cat "${{ runner.temp }}/fix_response.json" 
            exit 1
          fi
          if ! jq -e . "${{ runner.temp }}/fix_response.json" > /dev/null 2>&1; then
            echo "::error::AI Lint Fix API response is not valid JSON."
            # cat "${{ runner.temp }}/fix_response.json" 
            exit 1
          fi

          FIX_API_SUCCESS=$(jq -r .success "${{ runner.temp }}/fix_response.json")
          echo "Fix API Reported Success (from JSON): $FIX_API_SUCCESS"
          echo "api_response_success=$FIX_API_SUCCESS" >> $GITHUB_OUTPUT
          echo "api_response_path=${{ runner.temp }}/fix_response.json" >> $GITHUB_OUTPUT
          echo "api_call_skipped=false" >> $GITHUB_OUTPUT

      - name: Apply AI Fixes to Local Files
        if: steps.call_fix_api.outputs.api_call_skipped != 'true' && steps.call_fix_api.outputs.api_response_success == 'true' && steps.check_artifact.outputs.artifact_valid == 'true'
        id: apply_fixes_locally
        run: |
          echo "--- Starting Apply AI Fixes Locally ---"
          FIX_RESPONSE_FILE="${{ steps.call_fix_api.outputs.api_response_path }}"
          CHANGES_MADE_MARKER_FILE=$(mktemp)
          echo "false" > "$CHANGES_MADE_MARKER_FILE" # Initialize marker to false

          LAST_COMMIT_MSG_ON_BRANCH=$(git log -1 --pretty=%B)
          echo "Last commit message on branch: $LAST_COMMIT_MSG_ON_BRANCH"
          if [[ "$LAST_COMMIT_MSG_ON_BRANCH" == "chore: AI-assisted lint fixes" ]]; then
            echo "::warning::The latest commit on the branch is already an AI lint fix. Skipping."
            echo "changes_made=false" >> $GITHUB_OUTPUT
            rm "$CHANGES_MADE_MARKER_FILE"
            exit 0
          fi
          
          echo "Applying fixes from $FIX_RESPONSE_FILE..."
          set +e
          FILE_PATHS_TO_PROCESS_OUTPUT=$(jq -r '.fixedFiles | to_entries[] | select(.value != null) | .key' "$FIX_RESPONSE_FILE")
          JQ_EXIT_CODE=$?
          set -e

          if [ "$JQ_EXIT_CODE" -ne 0 ]; then
            echo "::error:: jq command failed to extract file paths from API response. Cannot apply fixes."
            # cat "$FIX_RESPONSE_FILE" # Be cautious here
            echo "changes_made=false" >> $GITHUB_OUTPUT
            rm "$CHANGES_MADE_MARKER_FILE"
            exit 1
          fi
          
          FILE_PATHS_TO_PROCESS="$FILE_PATHS_TO_PROCESS_OUTPUT"

          if [ -z "$FILE_PATHS_TO_PROCESS" ]; then
            echo "::notice::No files with non-null fixed content found in API response."
          else
            echo "File paths to process (one per line expected, space separated by default from shell var expansion):"
            echo "$FILE_PATHS_TO_PROCESS" # This will print paths space-separated if multiple
            echo "--- Processing each file path ---"
            
            # Use a for loop to iterate over words (paths) in FILE_PATHS_TO_PROCESS
            # This avoids subshell issues with 'while read' when fed by a pipe.
            for filepath_from_jq in $FILE_PATHS_TO_PROCESS; do
              # xargs is used to trim potential leading/trailing whitespace from each path part
              filepath=$(echo "$filepath_from_jq" | xargs) 
              if [ -z "$filepath" ]; then
                echo "::warning::Empty filepath encountered in loop. Skipping."
                continue
              fi
              echo "Processing filepath from loop: '$filepath'"

              fixedcontent=$(jq -r --arg pathkey "$filepath" '.fixedFiles[$pathkey]' "$FIX_RESPONSE_FILE")

              if [ "$fixedcontent" = "null" ] || [ -z "$fixedcontent" ]; then
                echo "::warning::Content for '$filepath' is null or empty in the API response. Skipping."
                continue
              fi
              if [ ! -f "$filepath" ]; then
                echo "::warning::File '$filepath' from API response not found in local checkout. Skipping."
                continue
              fi
              
              # echo "--- Original Content for '$filepath' (first 10 lines) ---" # Optional debug
              # head -n 10 "$filepath" | sed 's/^/    /'
              # echo "--- End Original Content Preview ---"
              # echo "--- AI Fixed Content for '$filepath' (first 10 lines) ---" # Optional debug
              # echo "$fixedcontent" | head -n 10 | sed 's/^/    /'
              # echo "--- End AI Fixed Content Preview ---"

              ORIGINAL_CONTENT_FOR_COMPARE=$(cat "$filepath")
              NORMALIZED_ORIGINAL_CONTENT=$(echo "$ORIGINAL_CONTENT_FOR_COMPARE" | tr -d '\r')
              NORMALIZED_FIXED_CONTENT=$(echo "$fixedcontent" | tr -d '\r')

              if [ "$NORMALIZED_ORIGINAL_CONTENT" != "$NORMALIZED_FIXED_CONTENT" ]; then
                echo "CONTENT DIFFERS for '$filepath'. Applying fix locally."
                echo "$fixedcontent" > "$filepath"
                echo "true" > "$CHANGES_MADE_MARKER_FILE" # Set marker if ANY file changes
              else
                echo "No actual content change (ignoring line endings) for '$filepath'."
              fi
            done
          fi
          
          FINAL_CHANGES_MADE_STATUS=$(cat "$CHANGES_MADE_MARKER_FILE")
          rm "$CHANGES_MADE_MARKER_FILE" # Clean up marker file

          if [ "$FINAL_CHANGES_MADE_STATUS" = "true" ]; then
            echo "Overall: Local file changes WERE made by AI."
            echo "changes_made=true" >> $GITHUB_OUTPUT
          else
            echo "Overall: NO local file changes were made by AI (or all content was identical)."
            echo "changes_made=false" >> $GITHUB_OUTPUT
          fi
          echo "--- End of Apply AI Fixes Locally ---"

      - name: Commit and Push changes using PAT
        if: steps.apply_fixes_locally.outputs.changes_made == 'true'
        uses: ad-m/github-push-action@v0.8.0 # Using a specific stable version
        with:
          github_token: ${{ secrets.AI_LINT_FIXER_PAT }}
          branch: ${{ env.PR_HEAD_BRANCH_FOR_PUSH }}
          commit_message: "chore: AI-assisted lint fixes"
          # Optional: configure committer and author if you want it different from PAT owner
          # committer_email: "ai-fixer-bot@online-everything-tool.com"
          # committer_name: "OET AI Fixer Bot"
          # author_email: "ai-fixer-bot@online-everything-tool.com" 
          # author_name: "OET AI Fixer Bot"
          force: false