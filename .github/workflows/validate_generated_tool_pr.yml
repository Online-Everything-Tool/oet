name: Validate Generated Tool PR

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - main

jobs:
  initial_checks:
    name: 1. Initial PR Validations
    if: >
      github.event_name == 'pull_request' &&
      startsWith(github.head_ref, 'feat/gen-') && 
      github.actor != 'dependabot[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: read

    outputs:
      pr_number: ${{ steps.set_pr_info.outputs.pr_number }}
      pr_sha: ${{ steps.set_pr_info.outputs.pr_sha }}
      head_ref: ${{ steps.set_pr_info.outputs.head_ref }} # Added for consistency
      tool_directive: ${{ steps.extract_directive_and_metadata.outputs.tool_directive }}
      tool_description: ${{ steps.extract_directive_and_metadata.outputs.tool_description }}
      path_validation_passed: ${{ steps.validate_paths.outputs.validation_passed || 'skipped' }}
      invalid_files_list: ${{ steps.validate_paths.outputs.invalid_files_list || '' }}
      analysis_succeeded: ${{ steps.analyze_name.outputs.analysis_succeeded }}
      ai_analysis_score: ${{ steps.analyze_name.outputs.score }}
      ai_analysis_is_typo: ${{ steps.analyze_name.outputs.is_typo }}
      ai_analysis_suggestions_json: ${{ steps.analyze_name.outputs.suggestions }}
      ai_analysis_reasoning: ${{ steps.analyze_name.outputs.reasoning }}
      critical_initial_checks_passed: ${{ steps.set_pr_info.outputs.should_run == 'true' && (steps.validate_paths.outputs.validation_passed == 'true' || steps.validate_paths.outcome == 'skipped') && steps.extract_directive_and_metadata.outputs.metadata_ok == 'true' }}

    steps:
      - name: Set PR Info 
        id: set_pr_info
        # This step now only runs for pull_request events due to job 'if'
        run: |
          echo "::group::Set PR Info"
          # These are now directly from the pull_request event context
          PR_NUMBER="${{ github.event.pull_request.number }}"
          HEAD_REF="${{ github.head_ref }}" # Same as github.event.pull_request.head.ref
          PR_SHA="${{ github.event.pull_request.head.sha }}"
          SHOULD_RUN="true" # If job 'if' passed, we should run

          echo "PR Number: $PR_NUMBER"
          echo "Head Ref (Branch): $HEAD_REF"
          echo "PR SHA: $PR_SHA"
          
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "head_ref=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "pr_sha=${PR_SHA}" >> $GITHUB_OUTPUT
          echo "should_run=${SHOULD_RUN}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Checkout code
        # This step only runs if initial_checks job 'if' passes
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.set_pr_info.outputs.pr_sha }} # Use SHA from set_pr_info
          fetch-depth: 0

      - name: Extract Tool Directive & Read Metadata Description
        id: extract_directive_and_metadata
        # This step only runs if initial_checks job 'if' passes
        run: |
          BRANCH_NAME="${{ steps.set_pr_info.outputs.head_ref }}"
          TEMP_DIRECTIVE=${BRANCH_NAME#feat/gen-}
          TOOL_DIRECTIVE=$(echo "$TEMP_DIRECTIVE" | sed 's/-[0-9]*$//')
          
          if [ -z "$TOOL_DIRECTIVE" ]; then 
            echo "::error::Could not extract tool directive from branch name '$BRANCH_NAME'."
            echo "tool_directive=" >> $GITHUB_OUTPUT
            echo "tool_description=" >> $GITHUB_OUTPUT
            echo "metadata_ok=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Extracted Tool Directive: $TOOL_DIRECTIVE"
          echo "tool_directive=${TOOL_DIRECTIVE}" >> $GITHUB_OUTPUT

          METADATA_FILE_PATH="app/tool/${TOOL_DIRECTIVE}/metadata.json"
          echo "Attempting to read metadata from: $METADATA_FILE_PATH"

          if [ ! -f "$METADATA_FILE_PATH" ]; then
            echo "::error file=${METADATA_FILE_PATH}::Required metadata.json file not found for tool directive '$TOOL_DIRECTIVE'."
            echo "tool_description=" >> $GITHUB_OUTPUT
            echo "metadata_ok=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          TOOL_DESCRIPTION=$(jq -r '.description // ""' "$METADATA_FILE_PATH")

          if [ -z "$TOOL_DESCRIPTION" ] || [ "$TOOL_DESCRIPTION" == "null" ]; then
            echo "::error file=${METADATA_FILE_PATH}::'description' field is missing, empty, or null in $METADATA_FILE_PATH."
            echo "tool_description=" >> $GITHUB_OUTPUT
            echo "metadata_ok=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "Successfully extracted tool description: $TOOL_DESCRIPTION"
          echo "tool_description=${TOOL_DESCRIPTION}" >> $GITHUB_OUTPUT
          echo "metadata_ok=true" >> $GITHUB_OUTPUT

      - name: Analyze Directive Name (AI Check)
        if: |
          steps.extract_directive_and_metadata.outputs.metadata_ok == 'true' &&
          github.event.action == 'opened'
        id: analyze_name
        env:
          APP_URL: ${{ secrets.APP_URL || 'https://online-everything-tool.com' }}
        run: |
          TOOL_DIRECTIVE="${{ steps.extract_directive_and_metadata.outputs.tool_directive }}"
          TOOL_DESCRIPTION="${{ steps.extract_directive_and_metadata.outputs.tool_description }}"
          CLEANED_APP_URL=$(echo "${APP_URL}" | sed 's:/*$::')
          API_ENDPOINT="${CLEANED_APP_URL}/api/analyze-directive-name" 

          EXISTING_DIRECTIVES_JSON='[]' # Assuming this will be populated if needed from a file or API later

          echo "Attempting AI Analysis API call to: $API_ENDPOINT for directive: $TOOL_DIRECTIVE"
          HTTP_STATUS=$(curl -L --max-redirs 3 -s -w "%{http_code}" -X POST "$API_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "{
                  \"proposedDirective\": \"$TOOL_DIRECTIVE\",
                  \"existingDirectives\": $EXISTING_DIRECTIVES_JSON,
                  \"generativeDescription\": \"$TOOL_DESCRIPTION\"
                }" \
            -o response.json)

          echo "AI Analysis API HTTP Status (after potential redirects): $HTTP_STATUS"
          ANALYSIS_SUCCEEDED_FLAG="false"; SCORE_VAL="N/A"; IS_TYPO_VAL="N/A"; SUGGESTIONS_JSON_STR="[]"; REASONING_TEXT="Analysis could not be performed."

          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]] && jq -e . response.json > /dev/null 2>&1; then
             echo "AI Analysis API call successful and response is valid JSON."
             SCORE_VAL=$(jq -r '.score // 0.5' response.json)
             IS_TYPO_VAL=$(jq -r '.is_likely_typo // false' response.json)
             SUGGESTIONS_JSON_STR=$(jq -c '.suggestions // []' response.json) 
             REASONING_TEXT=$(jq -r '.reasoning // "Analysis incomplete."' response.json)
             ANALYSIS_SUCCEEDED_FLAG="true"
          else
             echo "::warning::AI Analysis API call failed or returned invalid JSON (HTTP Status: $HTTP_STATUS). Analysis results will be marked as N/A."
          fi

          echo "analysis_succeeded=$ANALYSIS_SUCCEEDED_FLAG" >> $GITHUB_OUTPUT
          echo "score=$SCORE_VAL" >> $GITHUB_OUTPUT
          echo "is_typo=$IS_TYPO_VAL" >> $GITHUB_OUTPUT
          echo "suggestions=$SUGGESTIONS_JSON_STR" >> $GITHUB_OUTPUT
          {
            echo "reasoning<<EOF_REASONING"
            echo "$REASONING_TEXT"
            echo "EOF_REASONING"
          } >> $GITHUB_OUTPUT

      - name: Validate Changed File Paths
        if: |
          steps.extract_directive_and_metadata.outputs.metadata_ok == 'true' &&
          github.event.action == 'opened'
        id: validate_paths
        env:
          TOOL_DIRECTIVE: ${{ steps.extract_directive_and_metadata.outputs.tool_directive }}
        run: |
          echo "Running path validation because it's a 'pull_request.opened' event."    
          if [ -z "$TOOL_DIRECTIVE" ]; then 
            echo "::error::TOOL_DIRECTIVE not set for path validation."
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          # Using github.event.pull_request.base.sha for comparison against the PR's base commit
          # This requires fetch-depth: 0 on the main checkout if base is far behind
          # A simpler approach for PRs is often comparing against merge-base with the target branch (e.g., main)
          # git fetch origin ${{ github.base_ref }} --depth=1 # Ensure base ref is fetched
          # BASE_SHA=$(git merge-base HEAD origin/${{ github.base_ref }})
          # For 'opened' event, compare against where the branch was created from (PR base)
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          echo "Base SHA for diff (PR base): $BASE_SHA"
          echo "Current Head SHA: ${{ steps.set_pr_info.outputs.pr_sha }}"

          CHANGED_FILES_WITH_STATUS=$(git diff --name-status $BASE_SHA ${{ steps.set_pr_info.outputs.pr_sha }})
          if [ -z "$CHANGED_FILES_WITH_STATUS" ]; then 
            echo "No files changed compared to PR base. Assuming pass for path validation."
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          ALLOWED_FOLDER_PATTERN="^app/tool/${TOOL_DIRECTIVE}/"
          INVALID_FILES_FOUND=""
          ALL_PATHS_VALID=true
          echo "Validating changed file paths against pattern: $ALLOWED_FOLDER_PATTERN"
          echo "Changed files (Status Path):"
          echo "$CHANGED_FILES_WITH_STATUS"
          echo "$CHANGED_FILES_WITH_STATUS" | while IFS=$'\t' read -r status filepath; do
            if [ -z "$filepath" ]; then continue; fi
            # For PRs, status can be A (added), M (modified), D (deleted), R (renamed), C (copied)
            # We are mainly concerned with Added, Modified, Renamed (to ensure new path is valid)
            actual_path_to_check=$filepath
            if [[ "$status" == "R"* ]]; then # R095    old_path    new_path
                # For renames, the path listed after status is the *new* path if only one path is given by --name-status
                # If git diff shows two paths for rename, need to adjust. Assuming simple case here.
                # A safer way for renames is `git diff --name-only --diff-filter=R $BASE_SHA HEAD` then check each.
                # For simplicity with name-status, if status is R, filepath is new_path.
                echo "Rename detected, checking new path: $filepath"
            fi
            
            # Only validate paths for Added, Modified, Renamed (new path)
            if [[ "$status" == "A" || "$status" == "M" || "$status" == "C" || "$status" == R* ]]; then
              if [[ ! "$actual_path_to_check" =~ $ALLOWED_FOLDER_PATTERN ]]; then
                echo "::error file=$actual_path_to_check::Invalid path. File status: $status. Must be within '$ALLOWED_FOLDER_PATTERN'."
                INVALID_FILES_FOUND="${INVALID_FILES_FOUND}${actual_path_to_check} (Status: ${status})\n"
                ALL_PATHS_VALID=false
              else
                echo "Valid path: $actual_path_to_check (Status: $status)"
              fi
            else
              echo "Skipping strict path validation for file with status '$status': $filepath (e.g., Deletions)"
            fi
          done
          if $ALL_PATHS_VALID; then
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            INVALID_FILES_ESCAPED="${INVALID_FILES_FOUND//'%'/'%25'}"
            INVALID_FILES_ESCAPED="${INVALID_FILES_ESCAPED//$'\n'/'%0A'}"
            INVALID_FILES_ESCAPED="${INVALID_FILES_ESCAPED//$'\r'/'%0D'}"
            echo "invalid_files_list=${INVALID_FILES_ESCAPED}" >> $GITHUB_OUTPUT
            # Do not exit 1 here, let the critical_initial_checks_passed handle overall outcome
          fi
  
  analyze_dependencies:
    name: 2. Analyze & Prepare Dependencies
    needs: initial_checks
    if: success() && needs.initial_checks.outputs.critical_initial_checks_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      dependency_action_required: ${{ steps.check_deps.outputs.action_required }}
      asset_action_required: ${{ steps.check_deps.outputs.asset_action_required }} # For future AAP
    permissions:
      contents: read 
      actions: write 

    steps:
      - name: Checkout PR Code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.initial_checks.outputs.pr_sha }}

      - name: Check for New Undeclared Dependencies & Asset Instructions
        id: check_deps
        env:
          TOOL_DIRECTIVE: ${{ needs.initial_checks.outputs.tool_directive }}
          TOOL_DESCRIPTION: ${{ needs.initial_checks.outputs.tool_description }}
        run: |
          set -e 
          echo "--- Starting: Check for New Dependencies & Asset Instructions ---"
          echo "Tool Directive: $TOOL_DIRECTIVE"
          
          DEPS_ARTIFACT_CONTENT_PATH="${{ runner.temp }}/pending_dependencies.json"
          ASSET_ARTIFACT_CONTENT_PATH="${{ runner.temp }}/asset_instructions_payload.json" # For AAP
          TOOL_INFO_FILE_PATH="app/tool/${TOOL_DIRECTIVE}/tool-generation-info.json"
          PACKAGE_JSON_FILE_PATH="package.json"

          DEPS_ACTION_REQUIRED="false"
          ASSET_ACTION_REQUIRED="false"

          if [ -z "$TOOL_DIRECTIVE" ]; then
            echo "::error::Environment variable TOOL_DIRECTIVE is not set."
            exit 1
          fi
          if [ ! -f "$PACKAGE_JSON_FILE_PATH" ]; then
            echo "::error::'$PACKAGE_JSON_FILE_PATH' not found."
            exit 1
          fi

          if [ ! -f "$TOOL_INFO_FILE_PATH" ]; then
            echo "::notice::'$TOOL_INFO_FILE_PATH' not found for tool '${TOOL_DIRECTIVE}'. No dependencies or asset instructions to process from it."
            echo "action_required=${DEPS_ACTION_REQUIRED}" >> $GITHUB_OUTPUT
            echo "asset_action_required=${ASSET_ACTION_REQUIRED}" >> $GITHUB_OUTPUT
            echo "--- Finished: No tool-generation-info.json found ---"
            exit 0
          fi

          echo "Reading 'tool-generation-info.json' from: $TOOL_INFO_FILE_PATH"
          IDENTIFIED_DEPS_JSON_STR=$(jq -r 'if .identifiedDependencies and (.identifiedDependencies | type == "array") then .identifiedDependencies | tojson else "[]" end' "$TOOL_INFO_FILE_PATH")
          ASSET_INSTRUCTIONS_STR=$(jq -r '.assetInstructions // ""' "$TOOL_INFO_FILE_PATH")
          
          # Process Dependencies
          if [ "$(echo "$IDENTIFIED_DEPS_JSON_STR" | jq -r 'length')" -gt 0 ]; then
            TEMP_NEW_DEPS_ACCUMULATOR_FILE=$(mktemp)
            echo "[]" > "$TEMP_NEW_DEPS_ACCUMULATOR_FILE"
            FOUND_NEW_DEP_MARKER_FILE=$(mktemp)
            echo "false" > "$FOUND_NEW_DEP_MARKER_FILE"

            echo "Comparing identified dependencies with '$PACKAGE_JSON_FILE_PATH'..."
            echo "$IDENTIFIED_DEPS_JSON_STR" | jq -c '.[]' | while IFS= read -r dep_obj_json; do
              packageName=$(echo "$dep_obj_json" | jq -r '.packageName')
              if [ "$packageName" = "null" ] || [ -z "$packageName" ]; continue; fi
              if ! jq -e --arg pkg "$packageName" '((.dependencies // {})[$pkg]) or ((.devDependencies // {})[$pkg])' "$PACKAGE_JSON_FILE_PATH" > /dev/null; then
                current_array_content=$(cat "$TEMP_NEW_DEPS_ACCUMULATOR_FILE")
                echo "$current_array_content" | jq --argjson obj "$dep_obj_json" '. + [$obj]' > "$TEMP_NEW_DEPS_ACCUMULATOR_FILE"
                echo "true" > "$FOUND_NEW_DEP_MARKER_FILE"
              fi
            done
            if [ "$(cat "$FOUND_NEW_DEP_MARKER_FILE")" = "true" ]; then
              DEPS_ACTION_REQUIRED="true"
              NEW_DEPS_FOR_ARTIFACT_CONTENT_JSON_STR=$(cat "$TEMP_NEW_DEPS_ACCUMULATOR_FILE")
              jq -n \
                --arg directive "$TOOL_DIRECTIVE" \
                --arg description "$TOOL_DESCRIPTION" \
                --argjson newDeps "$NEW_DEPS_FOR_ARTIFACT_CONTENT_JSON_STR" \
                --arg assetInst "$ASSET_INSTRUCTIONS_STR" \
                '{toolDirective: $directive, toolDescription: $description, newDependencies: $newDeps, assetInstructions: $assetInst}' > "$DEPS_ARTIFACT_CONTENT_PATH"
              echo "Created pending dependencies artifact content at: $DEPS_ARTIFACT_CONTENT_PATH"
              echo "deps_artifact_file_path=${DEPS_ARTIFACT_CONTENT_PATH}" >> $GITHUB_OUTPUT
            fi
            rm "$TEMP_NEW_DEPS_ACCUMULATOR_FILE" "$FOUND_NEW_DEP_MARKER_FILE"
          else
            echo "No 'identifiedDependencies' in '$TOOL_INFO_FILE_PATH'."
          fi

          # Process Asset Instructions (for future AAP)
          if [ -n "$ASSET_INSTRUCTIONS_STR" ] && [ "$ASSET_INSTRUCTIONS_STR" != "null" ]; then
            ASSET_ACTION_REQUIRED="true"
            jq -n \
              --arg directive "$TOOL_DIRECTIVE" \
              --arg instructions "$ASSET_INSTRUCTIONS_STR" \
              '{toolDirective: $directive, assetInstructions: $instructions}' > "$ASSET_ARTIFACT_CONTENT_PATH"
            echo "Created asset instructions artifact content at: $ASSET_ARTIFACT_CONTENT_PATH"
            echo "asset_artifact_file_path=${ASSET_ARTIFACT_CONTENT_PATH}" >> $GITHUB_OUTPUT
          else
            echo "No 'assetInstructions' in '$TOOL_INFO_FILE_PATH'."
          fi
          
          echo "action_required=${DEPS_ACTION_REQUIRED}" >> $GITHUB_OUTPUT
          echo "asset_action_required=${ASSET_ACTION_REQUIRED}" >> $GITHUB_OUTPUT
          echo "--- Finished: Check for New Dependencies & Asset Instructions ---"

      - name: Upload Pending Dependencies Artifact
        if: steps.check_deps.outputs.action_required == 'true' && steps.check_deps.outputs.deps_artifact_file_path != ''
        uses: actions/upload-artifact@v4
        with:
          name: pending-dependencies-${{ needs.initial_checks.outputs.pr_sha }}
          path: ${{ steps.check_deps.outputs.deps_artifact_file_path }} 
          if-no-files-found: error 

      - name: Upload Asset Instructions Artifact (for AAP)
        if: steps.check_deps.outputs.asset_action_required == 'true' && steps.check_deps.outputs.asset_artifact_file_path != ''
        uses: actions/upload-artifact@v4
        with:
          name: asset-instructions-${{ needs.initial_checks.outputs.pr_sha }}
          path: ${{ steps.check_deps.outputs.asset_artifact_file_path }}
          if-no-files-found: error

  build_and_run_douglas_checker:
    name: 3. Build Tool & Run Douglas Ethos Check
    needs: [initial_checks, analyze_dependencies]
    if: >
      success() &&
      needs.initial_checks.outputs.critical_initial_checks_passed == 'true' &&
      needs.analyze_dependencies.outputs.dependency_action_required == 'false' && 
      github.actor != 'dependabot[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: read

    outputs:
      build_command_failed_output: ${{ steps.build_oet.outputs.build_command_failed }}
      lint_errors_captured_for_ai_output: ${{ steps.capture_for_ai_fix.outputs.lint_errors_captured_for_ai }}
      douglas_check_step_outcome: ${{ steps.douglas_checker_run.outcome }}
      imgur_screenshot_url: ${{ steps.upload_to_imgur.outputs.image_url || '' }}

    steps:
      - name: Checkout OET Code (PR branch)
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.initial_checks.outputs.pr_sha }}
          fetch-depth: 0 # For build cache or other git operations if needed

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x' # Or your project's version from .nvmrc
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install OET Dependencies
        run: npm ci

      - name: Prepare for Static Build (Isolate New Tool)
        env:
          TOOL_DIRECTIVE: ${{ needs.initial_checks.outputs.tool_directive }}
        run: |
          echo "Isolating tool: $TOOL_DIRECTIVE for static check"
          if [ -z "$TOOL_DIRECTIVE" ]; then
            echo "::error::Tool directive not received. Cannot prune."
            exit 1
          fi
          echo "Removing app/api to prevent issues with 'output: export' during this validation build..."
          rm -rf app/api || echo "No app/api directory to remove or removal failed (continuing)."
          if [ -d "app/tool" ]; then
            echo "Pruning other tool directories from app/tool/ ..."
            cd app/tool
            ls -d */ 2>/dev/null | grep -v -E "^(${TOOL_DIRECTIVE}/|_components/|_hooks/)$" | xargs -r rm -rf
            cd ../.. 
          fi
          echo "Project structure minimally pruned for static check."

      - name: Build OET for Static Export (and check for lint issues)
        id: build_oet
        env:
          NEXT_OUTPUT_MODE: export 
        run: |
          echo "Attempting static build with NEXT_OUTPUT_MODE=${NEXT_OUTPUT_MODE}..."
          BUILD_LOG_FILE_PATH="${{ runner.temp }}/build_output.log"
          set +e 
          npm run build > "$BUILD_LOG_FILE_PATH" 2>&1
          BUILD_EXIT_CODE=$? 
          set -e 
          echo "npm run build exited with code: $BUILD_EXIT_CODE" 
          echo "--- Start of Build Output (from $BUILD_LOG_FILE_PATH) ---"
          if [ -f "$BUILD_LOG_FILE_PATH" ]; then cat "$BUILD_LOG_FILE_PATH"; else echo "ERROR: Build log file not found!"; fi
          echo "--- End of Build Output ---"

          if [ "$BUILD_EXIT_CODE" -ne 0 ]; then
            echo "build_command_failed=true" >> $GITHUB_OUTPUT
            echo "::warning::'npm run build' command failed."
          else
            echo "build_command_failed=false" >> $GITHUB_OUTPUT
          fi
          if [ -d "out" ]; then
            echo "build_succeeded_structurally=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Build output directory 'out' not found."
            echo "build_succeeded_structurally=false" >> $GITHUB_OUTPUT
            if [ "$BUILD_EXIT_CODE" -eq 0 ]; then 
                echo "build_command_failed=true" >> $GITHUB_OUTPUT # Override if out dir missing despite exit 0
            fi
          fi
          echo "build_log_path=$BUILD_LOG_FILE_PATH" >> $GITHUB_OUTPUT

      - name: Capture Lint Output and Changed Files for AI Fixer
        id: capture_for_ai_fix
        if: steps.build_oet.outputs.build_command_failed == 'true'
        env:
          TOOL_DIRECTIVE_PATH: app/tool/${{ needs.initial_checks.outputs.tool_directive }}
        run: |
          echo "--- Start of capture_for_ai_fix step ---"
          BUILD_LOG_FILE="${{ steps.build_oet.outputs.build_log_path }}"
          LINT_DATA_DIR="${{ runner.temp }}/lint-data-for-artifact"
          mkdir -p "$LINT_DATA_DIR"
          LINT_ERRORS_FILE="$LINT_DATA_DIR/lint_errors.txt"
          FILES_TO_CHECK_FILE="$LINT_DATA_DIR/files_to_check.txt"
          LINT_ERRORS_IDENTIFIED_FOR_AI_FLAG="false" 

          if [ -f "$BUILD_LOG_FILE" ]; then
            # Check for common Next.js/ESLint failure indicators
            if grep -q -E "Failed to compile.|Linting and checking validity of types failed|TypeScript error" "$BUILD_LOG_FILE"; then
              echo "MATCHED: Lint/compile failure found in build log."
              # Copy relevant part of log or full log
              cp "$BUILD_LOG_FILE" "$LINT_ERRORS_FILE"
              
              # Find relevant files for fixing
              find "$TOOL_DIRECTIVE_PATH" \( -name "*.ts" -o -name "*.tsx" \) -type f > "$FILES_TO_CHECK_FILE"
              if [ -s "$FILES_TO_CHECK_FILE" ]; then
                LINT_ERRORS_IDENTIFIED_FOR_AI_FLAG="true"
                echo "Files to check based on TOOL_DIRECTIVE_PATH:"
                cat "$FILES_TO_CHECK_FILE"
              else
                echo "::warning::Build failed, but NO .ts/.tsx files found in '$TOOL_DIRECTIVE_PATH'."
              fi
            else
              echo "NO MATCH: Standard lint/compile failure indicators NOT found in build log. Assuming non-lint build failure."
            fi
          else
            echo "::warning::Build output log ($BUILD_LOG_FILE) not found."
          fi
          echo "lint_errors_captured_for_ai=$LINT_ERRORS_IDENTIFIED_FOR_AI_FLAG" >> $GITHUB_OUTPUT
          echo "--- End of capture_for_ai_fix step ---"

      - name: Upload Lint Failure Artifact for AI Fixer
        if: steps.capture_for_ai_fix.outputs.lint_errors_captured_for_ai == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: lint-failure-data-${{ needs.initial_checks.outputs.pr_sha }}
          path: ${{ runner.temp }}/lint-data-for-artifact/
          if-no-files-found: warn # Warn if files are unexpectedly missing

      # Douglas Checker Steps (conditional on successful build and no lint issues for AI)
      - name: Serve Static Output Locally
        id: serve_static
        if: steps.build_oet.outputs.build_succeeded_structurally == 'true' && steps.capture_for_ai_fix.outputs.lint_errors_captured_for_ai != 'true'
        run: |
          echo "Starting static server for 'out' directory on port 3001..."
          if sudo fuser 3001/tcp > /dev/null 2>&1; then
            sudo fuser -k 3001/tcp || echo "Failed to kill process on port 3001, or it was already free."
            sleep 2 
          fi
          npx serve out -l 3001 & 
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT
          timeout 30s bash -c 'until curl -sSf http://localhost:3001 > /dev/null; do echo -n "."; sleep 1; done' \
          || (echo "::error::Local server did not start." && (sudo kill -9 $SERVER_PID || true) && exit 1)
          echo "Server is up!"
        continue-on-error: true # Important: allow subsequent cleanup/reporting

      - name: Clone Douglas Checker
        if: steps.serve_static.outcome == 'success'
        run: git clone https://github.com/Online-Everything-Tool/douglas.git ./douglas-checker

      - name: Install Douglas Checker Dependencies
        if: steps.serve_static.outcome == 'success'
        working-directory: ./douglas-checker
        run: npm ci # Assuming package-lock.json exists

      - name: Run Douglas Ethos Check
        id: douglas_checker_run
        if: steps.serve_static.outcome == 'success'
        working-directory: ./douglas-checker
        env:
          TOOL_DIRECTIVE: ${{ needs.initial_checks.outputs.tool_directive }}
        run: |
          TARGET_URL="http://localhost:3001/tool/$TOOL_DIRECTIVE/"
          SUMMARY_FILE_PATH="$RUNNER_TEMP/douglas_summary.md"
          SCREENSHOT_FILE_PATH="$RUNNER_TEMP/douglas_screenshot.png"
          # Ensure Douglas is compiled or run directly if it's JS/TS
          if [ ! -f "./dist/check-tool.js" ]; then # Adjust if entry point is different
            npx tsc || (echo "::error::Failed to compile Douglas checker." && exit 1)
          fi
          node ./dist/check-tool.js "$TARGET_URL" --outputSummaryFile "$SUMMARY_FILE_PATH" --screenshotPath "$SCREENSHOT_FILE_PATH"
        continue-on-error: true

      - name: Upload Screenshot to Imgur
        id: upload_to_imgur
        if: always() && steps.douglas_checker_run.outcome != 'skipped' && steps.serve_static.outcome == 'success'
        env:
          IMGUR_CLIENT_ID: ${{ secrets.IMGUR_CLIENT_ID }}
        run: |
          SCREENSHOT_FILE="$RUNNER_TEMP/douglas_screenshot.png"
          IMAGE_URL=""
          if [ -f "$SCREENSHOT_FILE" ]; then
            if [ -z "$IMGUR_CLIENT_ID" ]; then
              echo "::warning::IMGUR_CLIENT_ID secret not set."
            else
              RESPONSE=$(curl -s -X POST \
                -H "Authorization: Client-ID $IMGUR_CLIENT_ID" \
                -F "image=@$SCREENSHOT_FILE" \
                # ... (rest of Imgur upload params) ...
                https://api.imgur.com/3/image)
              UPLOAD_SUCCESS=$(echo "$RESPONSE" | jq -r .success)
              if [ "$UPLOAD_SUCCESS" = "true" ]; then
                IMAGE_URL=$(echo "$RESPONSE" | jq -r .data.link)
              else echo "::warning::Imgur upload failed."; fi
            fi
          else echo "::warning::Screenshot file $SCREENSHOT_FILE not found."; fi
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Upload Douglas Summary Artifact
        if: always() && steps.serve_static.outcome == 'success' # Ensure it runs if server started
        uses: actions/upload-artifact@v4
        with:
          name: douglas-summary-${{ github.run_id }}
          path: ${{ runner.temp }}/douglas_summary.md
          if-no-files-found: warn

      - name: Upload Douglas Screenshot Artifact (as fallback)
        if: always() && steps.serve_static.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: douglas-screenshot-${{ github.run_id }}
          path: ${{ runner.temp }}/douglas_screenshot.png
          if-no-files-found: warn

      - name: Kill Static Server
        if: always() && steps.serve_static.outcome == 'success' && steps.serve_static.outputs.server_pid
        run: (sudo kill -9 ${{ steps.serve_static.outputs.server_pid }} || true) && (sudo fuser -k 3001/tcp || true)

  report_pr_status:
    name: 4. Report PR Validation Status & Determine Outcome
    needs:
      - initial_checks
      - analyze_dependencies
      - build_and_run_douglas_checker
    # Ensure this job runs only if initial_checks actually ran and passed its critical validations
    if: always() && github.actor != 'dependabot[bot]' && needs.initial_checks.outputs.critical_initial_checks_passed == 'true'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      actions: read 

    steps:
      - name: Prepare Comment Data from Step Outputs
        id: prepare_data
        run: |
          # ... (this step remains the same, setting various ENV vars) ...
          echo "PR_NUMBER_VAL=${{ needs.initial_checks.outputs.pr_number }}" >> $GITHUB_ENV
          echo "TOOL_DIRECTIVE_VAL=${{ needs.initial_checks.outputs.tool_directive }}" >> $GITHUB_ENV
          echo "INITIAL_CHECKS_JOB_RESULT_VAL=${{ needs.initial_checks.result }}" >> $GITHUB_ENV
          echo "PATH_VALIDATION_PASSED_VAL=${{ needs.initial_checks.outputs.path_validation_passed }}" >> $GITHUB_ENV
          echo "INVALID_FILES_LIST_VAL=${{ needs.initial_checks.outputs.invalid_files_list }}" >> $GITHUB_ENV
          echo "AI_ANALYSIS_SUCCEEDED_VAL=${{ needs.initial_checks.outputs.analysis_succeeded }}" >> $GITHUB_ENV
          echo "AI_SCORE_VAL=${{ needs.initial_checks.outputs.ai_analysis_score }}" >> $GITHUB_ENV
          echo "AI_IS_TYPO_VAL=${{ needs.initial_checks.outputs.ai_analysis_is_typo }}" >> $GITHUB_ENV
          echo "AI_SUGGESTIONS_JSON_VAL=${{ needs.initial_checks.outputs.ai_analysis_suggestions_json }}" >> $GITHUB_ENV
          echo "CRITICAL_INITIAL_CHECKS_PASSED_VAL=${{ needs.initial_checks.outputs.critical_initial_checks_passed }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA_VAL=${{ needs.initial_checks.outputs.pr_sha }}" >> $GITHUB_ENV

          echo "ANALYZE_DEPENDENCIES_JOB_RESULT_VAL=${{ needs.analyze_dependencies.result }}" >> $GITHUB_ENV
          echo "DEPENDENCY_ACTION_REQUIRED_VAL=${{ needs.analyze_dependencies.outputs.dependency_action_required }}" >> $GITHUB_ENV
          
          echo "BUILD_DOUGLAS_JOB_RESULT_VAL=${{ needs.build_and_run_douglas_checker.result }}" >> $GITHUB_ENV
          echo "LINT_ERRORS_CAPTURED_VAL=${{ needs.build_and_run_douglas_checker.outputs.lint_errors_captured_for_ai_output }}" >> $GITHUB_ENV
          echo "DOUGLAS_CHECK_STEP_OUTCOME_VAL=${{ needs.build_and_run_douglas_checker.outputs.douglas_check_step_outcome }}" >> $GITHUB_ENV
          echo "IMGUR_SCREENSHOT_URL_VAL=${{ needs.build_and_run_douglas_checker.outputs.imgur_screenshot_url }}" >> $GITHUB_ENV

      - name: Download Douglas Summary Artifact
        id: download_summary
        # Ensure this only runs if the build_and_run_douglas_checker job actually attempted to run Douglas
        if: needs.build_and_run_douglas_checker.outputs.douglas_check_step_outcome && needs.build_and_run_douglas_checker.outputs.douglas_check_step_outcome != 'skipped'
        uses: actions/download-artifact@v4
        with:
          name: douglas-summary-${{ github.run_id }} 
          path: ${{ runner.temp }}/douglas-artifacts/summary
        continue-on-error: true

      - name: Read Douglas Summary Content into ENV var
        id: read_summary_content_to_env
        # This step runs if download was attempted, even if it failed (to handle empty summary)
        # but only if the douglas check itself wasn't skipped entirely by build_and_run_douglas_checker
        if: needs.build_and_run_douglas_checker.outputs.douglas_check_step_outcome && needs.build_and_run_douglas_checker.outputs.douglas_check_step_outcome != 'skipped'
        run: |
          SUMMARY_FILE="${{ runner.temp }}/douglas-artifacts/summary/douglas_summary.md"
          SUMMARY_CONTENT_FOR_ENV="Douglas summary not available or check skipped."
          if [ "${{ steps.download_summary.outcome }}" == "success" ] && [ -f "$SUMMARY_FILE" ] && [ -s "$SUMMARY_FILE" ]; then
            # Read, escape for multiline env var, and truncate if too long for typical env var limits
            # Using a simpler approach: just indicate it's available, script will read from file.
            # For github-script, it's better to pass file path and let script read it.
            # However, for this specific case, let's try to pass content if short, or a placeholder.
            # Actually, the previous idea of passing path to script was better. Let's revert to that idea for the script.
            # This step will just confirm if the file exists for the script to use.
            echo "DOUGLAS_SUMMARY_FILE_PATH_FOR_SCRIPT=$SUMMARY_FILE" >> $GITHUB_ENV
            echo "DOUGLAS_SUMMARY_AVAILABLE=true" >> $GITHUB_ENV
            echo "Read summary content from $SUMMARY_FILE"
          else
            echo "DOUGLAS_SUMMARY_AVAILABLE=false" >> $GITHUB_ENV
            echo "Douglas summary file not found or empty after download attempt."
          fi
        continue-on-error: true

      - name: Construct and Post PR Comment
        id: post_comment
        uses: actions/github-script@v7
        env:
          AI_REASONING_FROM_NEEDS: ${{ needs.initial_checks.outputs.ai_analysis_reasoning }} 
          # DOUGLAS_SUMMARY_FILE_PATH_ENV is set by the step above
          DOUGLAS_SUMMARY_FILE_PATH_ENV: ${{ env.DOUGLAS_SUMMARY_FILE_PATH_FOR_SCRIPT }}
          DOUGLAS_SUMMARY_IS_AVAILABLE_ENV: ${{ env.DOUGLAS_SUMMARY_AVAILABLE }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs').promises; // Require fs module for file reading

            const { repo, owner } = context.repo; 
            const issue_number = parseInt(process.env.PR_NUMBER_VAL, 10);

            if (isNaN(issue_number)) {
              core.setFailed("VPR Report: PR Number is not available for commenting.");
              return;
            }

            const toolDirective = process.env.TOOL_DIRECTIVE_VAL || "UnknownTool";
            const prHeadShaShort = (process.env.PR_HEAD_SHA_VAL || 'N/A').substring(0,7);
            const actionRunUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}?pr=${issue_number}`;
            let commentBody = `## 🤖 OET Tool PR Validation Status for \`${toolDirective}\`\n\nCommit: \`${prHeadShaShort}\` · [View Action Run (ID: ${process.env.GITHUB_RUN_ID})](${actionRunUrl})\n\n`;

            const initialChecksPassed = process.env.CRITICAL_INITIAL_CHECKS_PASSED_VAL === 'true';
            const depActionRequired = process.env.DEPENDENCY_ACTION_REQUIRED_VAL === 'true';
            const lintErrorsCaptured = process.env.LINT_ERRORS_CAPTURED_VAL === 'true';

            const initialChecksJobResult = process.env.INITIAL_CHECKS_JOB_RESULT_VAL;
            const analyzeDepsJobResult = process.env.ANALYZE_DEPENDENCIES_JOB_RESULT_VAL;
            const buildDouglasJobResult = process.env.BUILD_DOUGLAS_JOB_RESULT_VAL;
            const douglasCheckStepOutcome = process.env.DOUGLAS_CHECK_STEP_OUTCOME_VAL;
            
            commentBody += `### 1. Initial PR Validations (Job Status: ${initialChecksJobResult || 'N/A'})\n`;
            if (initialChecksJobResult === 'success' && initialChecksPassed) {
              commentBody += `✅ **Passed!** All initial structure and naming checks are okay.\n`;
            } else if (initialChecksJobResult === 'failure' || !initialChecksPassed) {
              commentBody += `🚨 **Failed!**\n`;
              if (process.env.PATH_VALIDATION_PASSED_VAL === 'false') {
                const invalidFiles = (process.env.INVALID_FILES_LIST_VAL || "List unavailable.").replace(/%0A/g, '\n    - ').replace(/%0D/g, '');
                commentBody += `  - **Path Validation Issue:** Files found outside allowed directory. Invalid files:\n    - ${invalidFiles}\n`;
              } else {
                commentBody += `  - One or more initial checks did not pass. Refer to Action logs for this job.\n`;
              }
            } else { 
               commentBody += `🟡 Initial validations were skipped or had an unexpected status (${initialChecksJobResult || 'N/A'}).\n`;
            }
            commentBody += `\n  **🤖 AI Directive Name Analysis:**\n`;
            if (process.env.AI_ANALYSIS_SUCCEEDED_VAL === 'true') {
              commentBody += `    - Score: **${process.env.AI_SCORE_VAL}** / Likely Typo: ${process.env.AI_IS_TYPO_VAL === 'true' ? '**Yes** ❗' : 'No'}\n`;
              let reasoning = process.env.AI_REASONING_FROM_NEEDS || "No reasoning provided.";
              // Reasoning is directly from 'needs' context, already a string.
              // If it were from an ENV var set by a 'run' step with multiline content, it would need specific handling.
              // For now, assume it's fine as is.
              commentBody += `    - Reasoning:\n        ${reasoning.replace(/\n/g, '\n        ')}\n`;
              try {
                const suggestions = JSON.parse(process.env.AI_SUGGESTIONS_JSON_VAL || '[]', (key, value) => {
                  // Basic sanitization for suggestions if they are not simple strings
                  if (Array.isArray(value)) {
                    return value.map(item => typeof item === 'string' ? item.replace(/[`*_{}[\]()#+\-.!]/g, '\\$&') : item);
                  }
                  return value;
                });
                if (suggestions.length > 0) {
                  commentBody += `    - Suggestions: ${suggestions.map(s => `\`${s}\``).join(', ')}\n`;
                }
              } catch (e) { console.warn("Error parsing AI suggestions JSON: " + e.message); }
            } else if (process.env.AI_ANALYSIS_SUCCEEDED_VAL === 'false') {
              commentBody += `    - ⚠️ AI name analysis could not be performed or API call failed.\n`;
            } else { // Skipped or undefined
              commentBody += `    - ℹ️ AI name analysis was skipped on this run (e.g. not initial PR open).\n`;
            }
            commentBody += "\n---\n";

            commentBody += `### 1B. Dependency Analysis (Job Status: ${analyzeDepsJobResult || 'N/A'})\n`;
            if (analyzeDepsJobResult === 'skipped') {
                commentBody += `🟡 Skipped.\n`;
            } else if (depActionRequired) {
                commentBody += `⏳ **Pending:** New dependencies identified. 'AI Dependency Manager' will run.\n`;
            } else if (analyzeDepsJobResult === 'success') {
                commentBody += `✅ No new dependencies require automatic action.\n`;
            } else { 
                commentBody += `🚨 **Failed!** Problem during dependency analysis.\n`;
            }
            commentBody += "\n---\n";

            commentBody += `### 2. Local Build & Douglas Ethos Check (Job Status: ${buildDouglasJobResult || 'N/A'})\n`;
            if (buildDouglasJobResult === 'skipped') {
              commentBody += `🟡 Skipped.\n`;
            } else if (lintErrorsCaptured) { 
              commentBody += `🟡 **Build Failed (Lint/Build Issues):** 'AI Lint Fixer' will run.\n`;
              commentBody += `   Douglas Ethos Check was skipped.\n`;
            } else if (buildDouglasJobResult === 'failure') { 
              commentBody += `🚨 **Build Failed (Other Issues)!** AI lint fix NOT attempted for this. Review logs.\n`;
            } else if (buildDouglasJobResult === 'success') { 
              commentBody += `✅ **Local Static Build Successful.**\n`;
              if (douglasCheckStepOutcome === 'success') {
                commentBody += `✅ **Douglas Ethos Check Passed!**\n`;
              } else if (douglasCheckStepOutcome === 'skipped') {
                commentBody += `🟡 Douglas Ethos Check was skipped.\n`;
              } else { 
                commentBody += `🚨 **Douglas Ethos Check FAILED or had issues!** (Outcome: ${douglasCheckStepOutcome || 'N/A'})\n`;
              }
              
              let douglasSummary = 'Douglas summary not available or check skipped.';
              const summaryFilePath = process.env.DOUGLAS_SUMMARY_FILE_PATH_ENV;
              const summaryIsAvailable = process.env.DOUGLAS_SUMMARY_IS_AVAILABLE_ENV === 'true';

              if (summaryIsAvailable && summaryFilePath) {
                try {
                  // Check existence again, as script context is different from `run` step's shell
                  // Await fs.access to check existence before reading.
                  // For simplicity, we'll trust the env var from the previous step for now.
                  // A more robust way: github.rest.actions.downloadArtifact and read from there if needed.
                  // But since 'read_summary_content_to_env' already did, let's assume if path is set, it's readable.
                  // This part is tricky without direct fs access or passing content.
                  // The previous 'read_summary_content_to_env' step should ideally set the content itself to an env var if small enough,
                  // or the script needs to be more complex to download and read artifacts.
                  // Let's assume for now summaryPath is set only if file exists AND is readable by 'run' step.
                  // We will use a placeholder if the file can't be read by this script.
                  // This script CANNOT directly use fs.readFile(summaryFilePath) if summaryFilePath is a runner path
                  // from a PREVIOUS job. It needs to be an artifact or content passed.
                  // The artifact "douglas-summary-${{ github.run_id }}" WAS downloaded by "Download Douglas Summary Artifact"
                  // So, summaryFilePath will be like ${{ runner.temp }}/douglas-artifacts/summary/douglas_summary.md

                  // THIS IS THE FIX: Use the `fs` module we required.
                  const fileContent = await fs.readFile(summaryFilePath, 'utf8');
                  douglasSummary = fileContent; // No need for replace of %0A, it's raw
                } catch (e) {
                  console.warn(`Could not read Douglas summary from path ${summaryFilePath} in script: ${e.message}`);
                  douglasSummary = "Error reading Douglas summary content in script.";
                }
              }
              
              if (douglasSummary && douglasSummary.trim() !== 'Douglas summary not available or check skipped.' && douglasSummary.trim() !== "Error reading Douglas summary content in script.") {
                commentBody += `\n${douglasSummary}\n`; 
              }
              const imgurUrl = process.env.IMGUR_SCREENSHOT_URL_VAL;
              if (imgurUrl) {
                commentBody += `\n   **Douglas's View (Screenshot):**\n   ![Douglas Screenshot](${imgurUrl})\n`;
              }
            }
            commentBody += "\n---\n";

            commentBody += `### 3. Overall Status for this Validation Run\n`;
            const allLocalChecksConsideredForThisRunPassed = 
                initialChecksJobResult === 'success' && initialChecksPassed &&
                analyzeDepsJobResult === 'success' && !depActionRequired &&
                buildDouglasJobResult === 'success' && !lintErrorsCaptured && douglasCheckStepOutcome === 'success';

            if (depActionRequired && analyzeDepsJobResult !== 'failure') { 
              commentBody += `⏳ **Next Step:** 'AI Dependency Manager' will run. Monitor PR checks.`;
            } else if (lintErrorsCaptured && buildDouglasJobResult !== 'failure' && !depActionRequired) { 
              core.setFailed("Build failed due to lint/build issues. AI Lint Fixer is expected to run."); // Ensure VPR fails
              commentBody += `⏳ **Next Step:** 'AI Lint Fixer' will run. Monitor PR checks.`;
            } else if (allLocalChecksConsideredForThisRunPassed) {
              commentBody += `✅ **All local OET validation checks passed!**\n`;
              commentBody += `   🚀 **Netlify Deploy Preview:** Monitor Netlify checks.`;
            } else {
              core.setFailed("One or more critical local OET checks failed. Review details.");
              commentBody += `‼️ **Manual Action Required:** One or more critical checks failed. Review details above and in [Action logs](${actionRunUrl}).\n`;
            }

            commentBody += `\n\n---\n*OET CI Bot Report for commit \`${prHeadShaShort}\`*`;

            try {
              await github.rest.issues.createComment({ owner, repo, issue_number, body: commentBody });
            } catch (e) {
              core.warning(`Failed to post PR comment: ${e.message}`);
            }