{
  "description": "Exact test for GzipFileExplorerClient.tsx TS2322 using previously provided full file content and exact error message.",
  "payload": {
    "filesToFix": [
      {
        "path": "app/tool/gzip-file-explorer/_components/GzipFileExplorerClient.tsx",
        "currentContent": "'use client';\n\nimport React, { useState, useCallback, useEffect, useMemo, useRef } from 'react';\nimport { useFileLibrary } from '@/app/context/FileLibraryContext';\nimport useToolState from '../../_hooks/useToolState';\nimport Button from '../../_components/form/Button';\nimport FileSelectionModal from '../../_components/shared/FileSelectionModal';\nimport FilenamePromptModal from '../../_components/shared/FilenamePromptModal';\nimport type { ToolMetadata as AppToolMetadata, OutputConfig } from '@/src/types/tools';\nimport type { StoredFile, InlineFile } from '@/src/types/storage'; // Added InlineFile here based on usage\nimport {\n  ArrowUpTrayIcon,\n  TrashIcon,\n  ExclamationTriangleIcon,\n  EyeIcon,\n} from '@heroicons/react/24/outline';\nimport { useMetadata } from '@/app/context/MetadataContext';\nimport useItdeTargetHandler, { IncomingSignal } from '../../_hooks/useItdeTargetHandler';\nimport { resolveItdeData, ResolvedItdeData } from '@/app/lib/itdeDataUtils';\nimport IncomingDataModal from '../../_components/shared/IncomingDataModal';\nimport ReceiveItdeDataTrigger from '../../_components/shared/ReceiveItdeDataTrigger';\nimport { OutputActionButtons } from '../../_components/shared/OutputActionButtons';\nimport useGzipDecompressor, { DecompressedInfo } from '../_hooks/useGzipDecompressor';\nimport DecompressedFilePreview from './DecompressedFilePreview';\nimport { formatBytes, isTextBasedMimeType } from '@/app/lib/utils';\nimport toolSpecificMetadata from '../metadata.json';\n\ninterface GzipExplorerState {\n  inputFileId: string | null;\n  inputFileName: string | null;\n  inputFileSize: number | null;\n  decompressedFileOriginalName: string | null;\n  decompressedFileMimeType: string | null;\n  decompressedFileComment: string | null;\n  decompressedFileModTime: number | null; // Store as timestamp\n  decompressedFileId: string | null; // For ITDE and library reference\n  processingError: string | null; // Error from useGzipDecompressor\n}\n\nconst DEFAULT_GZIP_EXPLORER_STATE: GzipExplorerState = {\n  inputFileId: null,\n  inputFileName: null,\n  inputFileSize: null,\n  decompressedFileOriginalName: null,\n  decompressedFileMimeType: null,\n  decompressedFileComment: null,\n  decompressedFileModTime: null,\n  decompressedFileId: null,\n  processingError: null,\n};\n\nconst ownMetadata = toolSpecificMetadata as AppToolMetadata;\n\ninterface GzipFileExplorerClientProps {\n  toolRoute: string;\n}\n\nexport default function GzipFileExplorerClient({ toolRoute }: GzipFileExplorerClientProps) {\n  const {\n    state: toolState,\n    setState: setToolState,\n    isLoadingState: isLoadingToolState,\n    saveStateNow,\n    clearStateAndPersist: clearToolStateAndPersist,\n  } = useToolState<GzipExplorerState>(toolRoute, DEFAULT_GZIP_EXPLORER_STATE);\n\n  const { getFile, addFile, cleanupOrphanedTemporaryFiles } = useFileLibrary();\n  const { getToolMetadata } = useMetadata();\n  const decompressor = useGzipDecompressor();\n\n  const [currentGzFile, setCurrentGzFile] = useState<StoredFile | null>(null);\n  const [decompressedBlobForActions, setDecompressedBlobForActions] = useState<Blob | null>(null);\n  \n  const [uiError, setUiError] = useState<string | null>(null);\n  const [isFileSelectionModalOpen, setIsFileSelectionModalOpen] = useState(false);\n  const [isPreviewModalOpen, setIsPreviewModalOpen] = useState(false);\n  const [isFilenameModalOpen, setIsFilenameModalOpen] = useState(false);\n  const [filenameActionContext, setFilenameActionContext] = useState<'download' | 'save' | null>(null);\n  \n  const [copySuccess, setCopySuccess] = useState(false);\n  const [saveSuccess, setSaveSuccess] = useState(false);\n  const [downloadSuccess, setDownloadSuccess] = useState(false);\n\n  const [userDeferredItdePopup, setUserDeferredItdePopup] = useState(false);\n  const initialToolStateLoadCompleteRef = useRef(false);\n  const directiveName = ownMetadata.directive;\n\n  // Effect to process file when currentGzFile changes or toolState.inputFileId changes\n  useEffect(() => {\n    if (isLoadingToolState && !initialToolStateLoadCompleteRef.current) return;\n    initialToolStateLoadCompleteRef.current = true;\n\n    if (currentGzFile) {\n      if (currentGzFile.id === toolState.inputFileId && decompressor.decompressedInfo && decompressor.decompressedInfo.originalGzFilename === currentGzFile.filename) {\n        // Already processed this file\n        return;\n      }\n      decompressor.decompressFile(currentGzFile);\n    } else if (toolState.inputFileId && !currentGzFile && !decompressor.isLoading) {\n      // Attempt to load from persisted state\n      getFile(toolState.inputFileId).then(file => {\n        if (file) {\n          setCurrentGzFile(file);\n        } else {\n          setUiError(`Failed to load previously selected GZIP file (ID: ${toolState.inputFileId}). It may no longer exist.`);\n          // Clear relevant parts of toolState if file not found\n          setToolState(prev => ({\n            ...prev,\n            inputFileId: null, inputFileName: null, inputFileSize: null,\n            decompressedFileId: null, decompressedFileOriginalName: null, \n            decompressedFileMimeType: null, decompressedFileComment: null, decompressedFileModTime: null,\n            processingError: \"Previous GZIP file not found.\"\n          }));\n        }\n      });\n    }\n  }, [toolState.inputFileId, currentGzFile, getFile, decompressor.decompressFile, decompressor.isLoading, decompressor.decompressedInfo, isLoadingToolState, setToolState]);\n\n  // Effect to update toolState when decompressor finishes\n  useEffect(() => {\n    if (decompressor.decompressedInfo) {\n      setToolState(prev => ({\n        ...prev,\n        inputFileName: decompressor.decompressedInfo!.originalGzFilename, // Set from actual processed file\n        decompressedFileOriginalName: decompressor.decompressedInfo!.name,\n        decompressedFileMimeType: decompressor.decompressedInfo!.type,\n        decompressedFileComment: decompressor.decompressedInfo!.comment || null,\n        decompressedFileModTime: decompressor.decompressedInfo!.modTime?.getTime() || null,\n        processingError: null,\n        decompressedFileId: prev.inputFileName === decompressor.decompressedInfo!.originalGzFilename ? prev.decompressedFileId : null,\n      }));\n      setDecompressedBlobForActions(decompressor.decompressedInfo.blob);\n      setUiError(null);\n    } else if (decompressor.error) {\n      setToolState(prev => ({ ...prev, processingError: decompressor.error, decompressedFileId: null }));\n      setDecompressedBlobForActions(null);\n      setUiError(decompressor.error); // Also show in general UI error\n    }\n  }, [decompressor.decompressedInfo, decompressor.error, setToolState]);\n\n\n  const handleFileSelectedFromModal = useCallback(async (files: StoredFile[]) => {\n    setIsFileSelectionModalOpen(false);\n    setUiError(null);\n    decompressor.clearDecompressedInfo(); // Clear previous decompression results\n    \n    const file = files[0];\n    if (file) {\n      if (file.type === 'application/gzip' || file.type === 'application/x-gzip' || file.filename.toLowerCase().endsWith('.gz')) {\n        const oldInputFileId = toolState.inputFileId;\n        const oldDecompressedFileId = toolState.decompressedFileId;\n\n        setCurrentGzFile(file); // This will trigger decompression effect\n        setToolState(prev => ({\n            ...DEFAULT_GZIP_EXPLORER_STATE, // Reset most state for new file\n            inputFileId: file.id,\n            inputFileSize: file.size,\n        }));\n        \n        const idsToCleanup: string[] = [];\n        if (oldDecompressedFileId) {\n            const oldDecompressed = await getFile(oldDecompressedFileId);\n            if (oldDecompressed?.isTemporary) {\n                idsToCleanup.push(oldDecompressedFileId);\n            }\n        }\n        if (idsToCleanup.length > 0) {\n            cleanupOrphanedTemporaryFiles(idsToCleanup).catch(e => console.error(\"Cleanup failed for old temp files:\", e));\n        }\n\n      } else {\n        setUiError('Invalid file type. Please select a .gz file.');\n      }\n    }\n  }, [decompressor, toolState.inputFileId, toolState.decompressedFileId, setToolState, getFile, cleanupOrphanedTemporaryFiles]);\n\n  const handleClear = useCallback(async () => {\n    const currentDecompressedId = toolState.decompressedFileId;\n    decompressor.clearDecompressedInfo();\n    setCurrentGzFile(null);\n    setDecompressedBlobForActions(null);\n    setUiError(null);\n    await clearToolStateAndPersist(); \n\n    if (currentDecompressedId) {\n      const decompressedFile = await getFile(currentDecompressedId);\n      if (decompressedFile?.isTemporary) {\n        cleanupOrphanedTemporaryFiles([currentDecompressedId]).catch(e => console.error(\"Cleanup failed for temporary decompressed file on clear:\", e));\n      }\n    }\n  }, [clearToolStateAndPersist, decompressor, toolState.decompressedFileId, getFile, cleanupOrphanedTemporaryFiles]);\n\n  const handleProcessIncomingSignal = useCallback(async (signal: IncomingSignal) => {\n    setUiError(null);\n    decompressor.clearDecompressedInfo();\n    const sourceMeta = getToolMetadata(signal.sourceDirective);\n    if (!sourceMeta) {\n      setUiError(`Metadata not found for source: ${signal.sourceToolTitle}`);\n      return;\n    }\n    const resolvedPayload: ResolvedItdeData = await resolveItdeData(signal.sourceDirective, sourceMeta.outputConfig);\n    if (resolvedPayload.type === 'error' || resolvedPayload.type === 'none' || !resolvedPayload.data || resolvedPayload.data.length === 0) {\n      setUiError(resolvedPayload.errorMessage || 'No data received from source.');\n      return;\n    }\n    const receivedFileItem = resolvedPayload.data[0];\n    let fileToProcess: StoredFile | null = null;\n\n    if (receivedFileItem && (receivedFileItem.type === 'application/gzip' || receivedFileItem.type === 'application/x-gzip' || ('filename' in receivedFileItem && (receivedFileItem as StoredFile).filename.toLowerCase().endsWith('.gz')))) {\n      if (!('id' in receivedFileItem)) { // InlineFile\n        try {\n          const tempName = `itde-received-${Date.now()}.gz`;\n          const newId = await addFile(receivedFileItem.blob, tempName, receivedFileItem.type, true); // Save as temp\n          // THE LINE THAT CAUSES THE ERROR\n          fileToProcess = await getFile(newId);\n          if (!fileToProcess) throw new Error('Failed to retrieve saved InlineFile for ITDE');\n        } catch (e) {\n          setUiError(`Failed to process incoming GZIP: ${e instanceof Error ? e.message : String(e)}`);\n          return;\n        }\n      } else { // StoredFile\n        fileToProcess = receivedFileItem as StoredFile;\n      }\n    } else if (receivedFileItem) {\n      setUiError(`Received file from ${signal.sourceToolTitle} is not a GZIP (type: ${receivedFileItem.type}).`);\n      return;\n    }\n\n    if (fileToProcess) {\n      handleFileSelectedFromModal([fileToProcess]); \n      setUserDeferredItdePopup(false);\n    } else {\n      setUiError('No valid GZIP file found in ITDE data.');\n    }\n  }, [decompressor, getToolMetadata, addFile, getFile, handleFileSelectedFromModal]);\n\n  const itdeTarget = useItdeTargetHandler({\n    targetToolDirective: directiveName,\n    onProcessSignal: handleProcessIncomingSignal,\n  });\n\n  useEffect(() => {\n    if (initialToolStateLoadCompleteRef.current && itdeTarget.pendingSignals.length > 0 && !itdeTarget.isModalOpen && !userDeferredItdePopup) {\n      itdeTarget.openModalIfSignalsExist();\n    }\n  }, [itdeTarget, userDeferredItdePopup]);\n\n  const handleFilenameConfirm = useCallback(async (filename: string) => {\n    setIsFilenameModalOpen(false);\n    if (!decompressedBlobForActions || !toolState.decompressedFileOriginalName || !toolState.decompressedFileMimeType) {\n      setUiError('No decompressed content available to ' + (filenameActionContext || 'process') + '.');\n      return;\n    }\n    const action = filenameActionContext;\n    setFilenameActionContext(null);\n\n    const finalFilename = filename.trim() || toolState.decompressedFileOriginalName || 'decompressed_file';\n\n    if (action === 'download') {\n      try {\n        const url = URL.createObjectURL(decompressedBlobForActions);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = finalFilename;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n        setDownloadSuccess(true);\n        setTimeout(() => setDownloadSuccess(false), 2000);\n      } catch (err) {\n        setUiError(`Download failed: ${err instanceof Error ? err.message : 'Unknown error'}`);\n      }\n    } else if (action === 'save') {\n      try {\n        const newFileId = await addFile(decompressedBlobForActions, finalFilename, toolState.decompressedFileMimeType, false, toolRoute); // Save permanently\n        setToolState(prev => ({ ...prev, decompressedFileId: newFileId }));\n        setSaveSuccess(true);\n        setTimeout(() => setSaveSuccess(false), 2000);\n      } catch (err) {\n        setUiError(`Save to library failed: ${err instanceof Error ? err.message : 'Unknown error'}`);\n      }\n    }\n  }, [decompressedBlobForActions, toolState, filenameActionContext, addFile, setToolState, toolRoute]);\n\n  const initiateOutputAction = (action: 'download' | 'save') => {\n    if (!decompressedBlobForActions) {\n      setUiError('No decompressed content to ' + action + '.');\n      return;\n    }\n    setFilenameActionContext(action);\n    setIsFilenameModalOpen(true);\n  };\n\n  const handleCopyToClipboard = useCallback(async () => {\n    if (!decompressedBlobForActions || !toolState.decompressedFileMimeType || !isTextBasedMimeType(toolState.decompressedFileMimeType)) {\n      setUiError('Cannot copy: content is not text or not available.');\n      return;\n    }\n    try {\n      const text = await decompressedBlobForActions.text();\n      await navigator.clipboard.writeText(text);\n      setCopySuccess(true);\n      setTimeout(() => setCopySuccess(false), 2000);\n    } catch (err) {\n      setUiError(`Copy to clipboard failed: ${err instanceof Error ? err.message : 'Unknown error'}`);\n    }\n  }, [decompressedBlobForActions, toolState.decompressedFileMimeType]);\n\n  const onBeforeSignalSend = useCallback(async (): Promise<boolean> => {\n    if (toolState.decompressedFileId) return true; // Already in library\n\n    if (!decompressedBlobForActions || !toolState.decompressedFileOriginalName || !toolState.decompressedFileMimeType) {\n      setUiError(\"Decompressed file data is not ready to be sent.\");\n      return false;\n    }\n    try {\n      const newId = await addFile(\n        decompressedBlobForActions,\n        toolState.decompressedFileOriginalName,\n        toolState.decompressedFileMimeType,\n        true, // Mark as temporary for ITDE\n        toolRoute\n      );\n      const newState = { ...toolState, decompressedFileId: newId };\n      setToolState(newState);\n      await saveStateNow(newState); // Persist the new ID\n      return true;\n    } catch (err) {\n      setUiError(`Failed to prepare file for sending: ${err instanceof Error ? err.message : \"Unknown error\"}`);\n      return false;\n    }\n  }, [toolState, decompressedBlobForActions, addFile, setToolState, saveStateNow, toolRoute]);\n\n  const itdeOutputItems = useMemo((): StoredFile[] => {\n    if (toolState.decompressedFileId && toolState.decompressedFileOriginalName && toolState.decompressedFileMimeType && decompressedBlobForActions) {\n      return [{\n        id: toolState.decompressedFileId,\n        filename: toolState.decompressedFileOriginalName,\n        type: toolState.decompressedFileMimeType,\n        size: decompressedBlobForActions.size,\n        blob: decompressedBlobForActions, \n        createdAt: toolState.decompressedFileModTime ? new Date(toolState.decompressedFileModTime) : new Date(),\n        isTemporary: true, \n      }];\n    }\n    return [];\n  }, [toolState, decompressedBlobForActions]);\n\n  const isLoadingOverall = isLoadingToolState || decompressor.isLoading;\n  const canPerformOutputActions = !!decompressedBlobForActions && !decompressor.isLoading && !decompressor.error;\n\n  if (isLoadingToolState && !initialToolStateLoadCompleteRef.current) {\n    return <p className=\"text-center p-4 italic text-[rgb(var(--color-text-muted))] animate-pulse\">Loading Gzip Explorer...</p>;\n  }\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"p-4 border border-[rgb(var(--color-border-base))] rounded-md bg-[rgb(var(--color-bg-subtle))] space-y-3\">\n        <div className=\"flex flex-wrap gap-2 items-center\">\n          <Button\n            variant=\"primary\"\n            onClick={() => setIsFileSelectionModalOpen(true)}\n            disabled={isLoadingOverall}\n            iconLeft={<ArrowUpTrayIcon className=\"h-5 w-5\" />}\n          >\n            Select .gz File\n          </Button>\n          {(currentGzFile || toolState.inputFileName || uiError || toolState.processingError) && (\n            <Button\n              variant=\"danger\"\n              onClick={handleClear}\n              disabled={isLoadingOverall}\n              iconLeft={<TrashIcon className=\"h-5 w-5\" />}\n            >\n              Clear\n            </Button>\n          )}\n          <div className=\"ml-auto\">\n            <ReceiveItdeDataTrigger\n              hasDeferredSignals={itdeTarget.pendingSignals.length > 0 && userDeferredItdePopup && !itdeTarget.isModalOpen}\n              pendingSignalCount={itdeTarget.pendingSignals.length}\n              onReviewIncomingClick={itdeTarget.openModalIfSignalsExist}\n            />\n          </div>\n        </div>\n        <div className=\"mt-2 text-sm text-[rgb(var(--color-text-muted))] min-h-[1.25rem]\">\n          {isLoadingOverall && toolState.inputFileName && <span>Processing: <em>{toolState.inputFileName}</em>...</span>}\n          {!isLoadingOverall && toolState.inputFileName && <span>Loaded GZIP: <strong>{toolState.inputFileName}</strong> ({toolState.inputFileSize ? formatBytes(toolState.inputFileSize) : 'size unknown'})</span>}\n          {!isLoadingOverall && !toolState.inputFileName && <span>Ready for a .gz file.</span>}\n        </div>\n      </div>\n\n      {(uiError || toolState.processingError) && (\n        <div role=\"alert\" className=\"p-3 bg-[rgb(var(--color-bg-error-subtle))] border border-[rgb(var(--color-border-error))] text-[rgb(var(--color-text-error))] rounded-md text-sm flex items-start gap-2\">\n          <ExclamationTriangleIcon className=\"h-5 w-5 flex-shrink-0 mt-0.5\" aria-hidden=\"true\" />\n          <div><strong className=\"font-semibold\">Error:</strong> {uiError || toolState.processingError}</div>\n        </div>\n      )}\n\n      {decompressor.decompressedInfo && !decompressor.error && (\n        <div className=\"p-4 border border-[rgb(var(--color-border-base))] rounded-md space-y-3\">\n          <h3 className=\"text-lg font-semibold text-[rgb(var(--color-text-base))]\">Decompressed File Information:</h3>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 text-sm\">\n            <div><strong>Original Name:</strong> {toolState.decompressedFileOriginalName || 'N/A'}</div>\n            <div><strong>MIME Type:</strong> {toolState.decompressedFileMimeType || 'N/A'}</div>\n            <div><strong>Size:</strong> {decompressedBlobForActions ? formatBytes(decompressedBlobForActions.size) : 'N/A'}</div>\n            {toolState.decompressedFileModTime && <div><strong>Mod. Time:</strong> {new Date(toolState.decompressedFileModTime).toLocaleString()}</div>}\n            {toolState.decompressedFileComment && <div className=\"md:col-span-2\"><strong>Comment:</strong> {toolState.decompressedFileComment}</div>}\n          </div>\n          <div className=\"flex flex-wrap gap-2 pt-2 border-t border-[rgb(var(--color-border-base))]\">\n            <Button \n              variant=\"neutral-outline\" \n              onClick={() => setIsPreviewModalOpen(true)} \n              disabled={!canPerformOutputActions}\n              iconLeft={<EyeIcon className=\"h-5 w-5\" />}\n            >\n              Preview\n            </Button>\n            <OutputActionButtons\n              canPerform={canPerformOutputActions}\n              isSaveSuccess={saveSuccess}\n              isCopySuccess={copySuccess}\n              isDownloadSuccess={downloadSuccess}\n              onInitiateSave={() => initiateOutputAction('save')}\n              onInitiateDownload={() => initiateOutputAction('download')}\n              onCopy={isTextBasedMimeType(toolState.decompressedFileMimeType) ? handleCopyToClipboard : undefined}\n              onClear={handleClear} \n              directiveName={directiveName}\n              outputConfig={ownMetadata.outputConfig as OutputConfig}\n              selectedOutputItems={itdeOutputItems}\n              canInitiateSave={!!decompressedBlobForActions}\n            />\n          </div>\n        </div>\n      )}\n\n      <FileSelectionModal\n        isOpen={isFileSelectionModalOpen}\n        onClose={() => setIsFileSelectionModalOpen(false)}\n        onFilesSelected={handleFileSelectedFromModal}\n        mode=\"selectExistingOrUploadNew\"\n        accept=\".gz,application/gzip,application/x-gzip\"\n        selectionMode=\"single\"\n        libraryFilter={{ type: 'application/gzip' }} \n        initialTab=\"upload\"\n      />\n      <DecompressedFilePreview\n        isOpen={isPreviewModalOpen}\n        onClose={() => setIsPreviewModalOpen(false)}\n        fileBlob={decompressedBlobForActions}\n        fileName={toolState.decompressedFileOriginalName}\n        fileMimeType={toolState.decompressedFileMimeType}\n      />\n      <FilenamePromptModal\n        isOpen={isFilenameModalOpen}\n        onClose={() => { setIsFilenameModalOpen(false); setFilenameActionContext(null); }}\n        onConfirm={handleFilenameConfirm}\n        initialFilename={toolState.decompressedFileOriginalName || 'decompressed_file'}\n        title={filenameActionContext === 'download' ? 'Enter Download Filename' : 'Enter Filename for Library'}\n        filenameAction={filenameActionContext || 'download'}\n      />\n      <IncomingDataModal\n        isOpen={itdeTarget.isModalOpen}\n        signals={itdeTarget.pendingSignals}\n        onAccept={(sd) => { itdeTarget.acceptSignal(sd); if (itdeTarget.pendingSignals.length -1 === 0) setUserDeferredItdePopup(false);}}\n        onIgnore={(sd) => { itdeTarget.ignoreSignal(sd); if (itdeTarget.pendingSignals.length -1 === 0) setUserDeferredItdePopup(false);}}\n        onDeferAll={() => { setUserDeferredItdePopup(true); itdeTarget.closeModal(); }}\n        onIgnoreAll={() => { setUserDeferredItdePopup(false); itdeTarget.ignoreAllSignals(); }}\n      />\n    </div>\n  );\n}\n"
      }
    ],
    "lintErrors": "./app/tool/gzip-file-explorer/_components/GzipFileExplorerClient.tsx\nType error: Type 'StoredFile | undefined' is not assignable to type 'StoredFile | null'.\n  Type 'undefined' is not assignable to type 'StoredFile | null'.\n\n  224 |           const tempName = `itde-received-${Date.now()}.gz`;\n  225 |           const newId = await addFile(receivedFileItem.blob, tempName, receivedFileItem.type, true); // Save as temp\n> 226 |           fileToProcess = await getFile(newId);\n      |           ^\n  227 |           if (!fileToProcess) throw new Error('Failed to retrieve saved InlineFile for ITDE');\n  228 |         } catch (e) {\n  229 |           setUiError(`Failed to process incoming GZIP: ${e instanceof Error ? e.message : String(e)}`);\n"
  }
}
